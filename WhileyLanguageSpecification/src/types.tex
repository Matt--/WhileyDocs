\chapter{Types \& Values}
\section{Overview}
Discuss syntactic versus semantic types, as well as the set of all values.  Probably discuss the different kinds of values which are possible, and the fact that every value has a single {\em concrete} type associate with it.  Also, need to consider constrained types as well as type patterns.

\begin{syntax}
  \verb+Type+ & $::=$ & \\
  & $|$ & \verb+TermType+ \\
  & $|$ & \verb+UnionType+ \\
  & $|$ & \verb+IntersectionType+ \\
\end{syntax}

\begin{syntax}
  \verb+TermType+ & $::=$ & \\
  & $|$ & \verb+PrimitiveType+ \\
  & $|$ & \verb+TupleType+ \\
  & $|$ & \verb+RecordType+ \\
  & $|$ & \verb+ReferenceType+ \\
  & $|$ & \verb+NominalType+ \\
  & $|$ & \verb+CollectionType+ \\
  & $|$ & \verb+NegationType+ \\
  & $|$ & \verb+FunctionType+ \\
  & $|$ & \verb+MethodType+ \\
\end{syntax}


\section{Primitives}

\begin{syntax}
  \verb+PrimitiveType+ & $::=$ & \\
  & $|$ & \verb+AnyType+ \\
  & $|$ & \verb+VoidType+ \\
  & $|$ & \verb+NullType+ \\
  & $|$ & \verb+BoolType+ \\
  & $|$ & \verb+ByteType+ \\
  & $|$ & \verb+CharType+ \\
  & $|$ & \verb+IntType+ \\
  & $|$ & \verb+RealType+ \\
\end{syntax}


% =======================================================================
% Null
% =======================================================================

\subsection{Null Type}

The null type is a special type which should be used to show the absence of something. It is distinct from void, since variables can hold the special \lstinline{null} value (where as there is no special ``\lstinline{void}'' value).  Variables of \lstinline{null} type support only equality (\lstinline{==}) and inequality comparisons (\lstinline{!=}).  The \lstinline{null} value is particularly useful for representing optional values and terminating recursive types.

\begin{syntax}
  \verb+NullType+ & $::=$ & \token{null} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{null} type:

\begin{lstlisting}
type Tree is null | { int data, Tree left, Tree right }

function height(Tree t) => int:
    if t is null:
        // height of empty tree is zero
        return 0
    else:
        // height is this node plus maximum height of subtrees
        return 1 + Math.max(height(t.left), height(t.right))
\end{lstlisting}
This defines \lstinline{Tree} --- a {\em recursive type} --- which is either empty (i.e. \lstinline{null}) or consists of a field \lstinline{data} and two subtrees, \lstinline{left} and \lstinline{right}.  The \lstinline{height} function calculates the height of a \lstinline{Tree} as the longest path from the root through the tree.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{null} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt null}\rrbracket & = & \{{\tt null}\}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{null} type is the singleton set containing exactly the \lstinline{null} value.


\paragraph{Notes.}  With all of the problems surrounding \lstinline{null} and \lstinline{NullPointerException}s in languages like Java and C, it may seem that this type should be avoided. However, it remains a very useful abstraction around (e.g. for terminating recursive types) and, in Whiley, is treated in a completely safe manner (unlike e.g. Java).

% =======================================================================
% Bool 
% =======================================================================

\subsection{Bool Type}

Represents the set of boolean values (i.e. \lstinline{true} and \lstinline{false}).

\begin{syntax}
 \verb+BoolType+ & $::=$ & \token{bool} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Bool 
% =======================================================================

\subsection{Byte Type}

Represents a sequence of 8 bits. 

\begin{syntax}
 \verb+ByteType+ & $::=$ & \token{byte} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  Unlike for many languages, there is no
representation associated with a byte. For example, to extract an
integer value from a byte, it must be explicitly decoded according to
some representation (e.g. two's compliment) using an auxillary function (e.g. \lstinline{Byte.toInt()}).


% =======================================================================
% Char
% =======================================================================

\subsection{Char Type}

Represents a arbitrary unicode character.

\begin{syntax}
  \verb+CharType+ & $::=$ & \token{char} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Int
% =======================================================================

\subsection{Int Type}

Represents the set of (unbound) integer values. 

\begin{syntax}
  \verb+IntType+ & $::=$ & \token{int} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  Since integer types in Whiley are unbounded, there
is no equivalent to Java's \lstinline{MIN_VALUE} and \lstinline{MAX_VALUE} for \lstinline{int} types.

% =======================================================================
% Real
% =======================================================================

\subsection{Real Type}

Represents the set of (unbound) rational numbers.

\begin{syntax}
  \verb+RealType+ & $::=$ & \token{real} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Any
% =======================================================================

\subsection{Any Type}

The type \lstinline{any} represents the type whose variables may hold any possible value.  Thus, \lstinline{any} is the {\em top type} (i.e. $\top$) in the lattice of types and, hence, is the supertype of all other types.  Variables of \lstinline{any} type support only equality (\lstinline{==}) and inequality comparisons (\lstinline{!=}) as well as {\em runtime type tests}.  Finally, unlike the majority of other types, there are no {\em values} of type \lstinline{any}.

\begin{syntax}
  \verb+AnyType+ & $::=$ & \token{any} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{any} type:

\begin{lstlisting}
function toInt(any val) => int:
    if val is int:
        return val
    else if val is real:
        return Math.floor(val)
    else:
        return 0 // default value        
\end{lstlisting}

Here, the function \lstinline{toInt} accepts {\em any valid Whiley value}, which includes all values of type \lstinline{int}, \lstinline{real}, collections, records, etc.  The function then inspects the value that it has been passed and, in the case of values of type \lstinline{int} and \lstinline{real}, returns an integer approximation; for all other values, it returns \lstinline{0}.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{any} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt any}\rrbracket & = & \mathcal{D}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{any} type equals the {\em domain} (i.e. the set of all values).

\paragraph{Notes.}  The any type is roughly comparable to the \lstinline{Object} type found in pure object-oriented languages.  However, in impure object-oriented languages which support primitive types, such as Java, this comparison often falls short because \lstinline{Object} is not a supertype of primitives such as \lstinline{int} or \lstinline{long}.

% =======================================================================
% Void 
% =======================================================================

\subsection{Void Type}

The \lstinline{void} type represents the type whose variables cannot exist (i.e. because they cannot hold any possible value).  Thus, \lstinline{void} is the {\em bottom type} (i.e. $\bot$) in the lattice of types and, hence, is the {\em subtype} of all other types.  Void is used to represent the return type of a method which does not return anything.  Furthermore, it is also used to represent the element type of an empty list of set.  Finally, unlike the majority of other types, there are no {\em values} of type \lstinline{void}.

\begin{syntax}
   \verb+VoidType+ & $::=$ & \token{void} \\
\end{syntax}

\paragraph{Examples.} The following example illustrates several uses of the \lstinline{void} type:

\begin{lstlisting}
// Attempt to update first element
method update1st(&[int] list, int value) => void:
    // First, check whether list is empty or not
    if *list != [void]:
       // Then, update 1st element
       (*list)[0] = x
    // done
\end{lstlisting}

Here, the method \lstinline{update1st} is declared to return
\lstinline{void} --- meaning it does not return a value.  Instead,
this method updates some existing state accessible through the
reference \lstinline{list}.  Within the method body, the value
accessible via this reference is compared against the
\lstinline{[void]} (i.e. the {\em empty list}).

\paragraph{Semantics.}  The set of values defined by the type
\lstinline{void} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt void}\rrbracket & = & \emptyset\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{void} type
equals the empty set.  

% =======================================================================
% Tuples
% =======================================================================

\section{Tuple Types}

A tuple type describes a compound type made up of two or more subcomponents. It is similar to a record, except that fields are effectively anonymous.

\begin{syntax}
  \verb+TupleType+ & $::=$ & \token{(}\ \verb+Type+\ \big(\ \token{,}\
  \verb+Type+\ \big)$^+$\ \token{)}\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Records
% =======================================================================

\section{Record Types}

A record is made up of a number of fields, each of which has a unique name. Each field has a corresponding type. One can think of a record as a special kind of "fixed" map (i.e. where we know exactly which entries we have).

\begin{syntax}
  \verb+RecordType+ & $::=$ & \token{\{}\ \verb+Type+\
  \verb+Ident+\ \big(\ \token{,}\ \verb+Type+\ \verb+Ident+\
  \big)$^*$ \big[\ \token{,}\ \token{...}\ \big]\ \token{\}}\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  Syntax for functions?  Open versus closed records?

% =======================================================================
% References
% =======================================================================

\section{Reference Types}

Represents a reference to an object in Whiley.

\begin{syntax}
  \verb+ReferenceType+ & $::=$ & \token{\&}\ \ \verb+Type+\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Nominal
% =======================================================================

\section{Nominal Types}

The existential type represents the an unknown type, defined at a given position.

\begin{syntax}
  \verb+NominalType+ & $::=$ & \verb+Ident+\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Collections
% =======================================================================

\section{Collection Types}

% =======================================================================
% Set
% =======================================================================

\subsection{Set Type}

A set type describes set values whose elements are subtypes of the element type. For example, \lstinline|{1,2,3}| is an instance of set type \lstinline|{int}|; however, \lstinline|{1.345}| is not.

\begin{syntax}
  \verb+SetType+ & $::=$ & \token{\{} \ \verb+Type+ \ \token{\}} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Map
% =======================================================================

\subsection{Map Type}

A map represents a one-many mapping from variables of one type to variables of another type. For example, the map type \lstinline|{int=>real}| represents a map from integers to real values. A valid instance of this type might be \lstinline|{1=>1.2,2=>3.0}|.

\begin{syntax}
  \verb+MapType+ & $::=$ & \token{\{} \ \verb+Type+ \ \token{=>} \ \verb+Type+ \ \token{\}} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% List
% =======================================================================

\subsection{List Type}

A list type describes list values whose elements are subtypes of the element type. For example, \lstinline{[1,2,3]} is an instance of list type \lstinline{[int]}; however, \lstinline{[1.345]} is not.

\begin{syntax}
  \verb+ListType+ & $::=$ & \token{[} \ \verb+Type+ \ \token{]}\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Functions
% =======================================================================

\section{Function Types}

\begin{syntax}
  \verb+FunctionType+ & $::=$ & \token{function}\ \token{(}\
  \big[\ \verb+Type+\ \big(\ \token{,}\ \verb+Type+\ \big)$^*$\ \big]\ \token{)}\ \token{=>}\ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Functions
% =======================================================================

\section{Method Types}

\begin{syntax}
  \verb+MethodType+ & $::=$ & \token{method}\ \token{(}\
  \big[\ \verb+Type+\ \big(\ \token{,}\ \verb+Type+\ \big)$^*$\ \big]\ \token{)}\ \token{=>}\ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Unions
% =======================================================================

\section{Union Types}

A union type represents a type whose variables may hold values from any of its "bounds". For example, the union type \lstinline{null|int} indicates a variable can either hold an integer value, or \lstinline{null}. 

\begin{syntax}
  \verb+UnionType+ & $::=$ & \verb+IntersectionType+\ \big(\ \token{|}\ \verb+IntersectionType+\
  \big)$^+$\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  There must be at least two bounds for a union type to make sense.

% =======================================================================
% Intersections
% =======================================================================

\section{Intersection Types}

\begin{syntax}
  \verb+IntersectionType+ & $::=$ & \verb+TermType+\ \big(\ \token{\&}\ \verb+TermType+\
  \big)$^+$\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Negations
% =======================================================================

\section{Negation Types}

\begin{syntax}
  NegationType & $::=$ & \token{!}\ \ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  A negation type represents a type which
accepts values {\em not} in a given type.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

\section{Abstract Types}
\subsection{Recursive Types}
\subsection{Effective Tuples}
\subsection{Effective Records}
\subsection{Effective Collections}

\section{Subtyping Algorithms}
Discussion of soundness and completeness.
