\chapter{Types}
The Whiley programming language is {\em statically typed}, meaning that every expression has a type determined at compile time.  Furthermore, evaluating an expression is guaranteed to yield a value of its type.  Whiley's {\em type system} governs how the type of any variable or expression is determined.  Whiley's type system is unusual in that it incorporates \gls{union_type}s~(\S\ref{c_types_unions}), \gls{intersection_type}s~(\S\ref{c_types_intersections}) and \gls{negation_type}s~(\S\ref{c_types_negations}), as well as employing {\em flow typing} and {\em structural typing}.

\section{Overview}
\label{c_types_type_overview}

Types in Whiley are unusual (in part) because there is a large gap between their {\em syntactic} description and their underlying {\em semantic} meaning.  In most programming languages (e.g. Java), this gap is either small or non-existent and, hence, there is little to worry about.  However, in Whiley, we must tread carefully to avoid confusion.  The following example attempts to illustrate this gap between the syntax and semantics of types:
\begin{lstlisting}
int|null id(null|int x):
    return x
\end{lstlisting}
In this function we see two distinct \gls{type_descriptor}s expressed in the program text, namely ``\lstinline{int|null}'' and ``\lstinline{null|int}''.  Type descriptors occur at the source-level and describe \gls{type}s which occur at the abstract (or underlying) level.  In this particular case, we have two distinct type descriptors which describe the {\em same} underlying type.  We will often refer to types as providing the semantic (i.e. meaning) of type descriptors.  

\subsection{Type Semantics}
\label{c_types_type_semantics}

Although types are abstract entities we can (for the most part) imagine them as describing sets of {\em abstract values}.  For example, \lstinline{int|null} denotes the set of values containing exactly the (infinite) set of integers and \lstinline{null} (i.e. ${\tt\mathbb{Z}\cup\{null\}}$).  This is often referred to as a set-theoretic interpretation of types~\cite{AW93,Damm94,CF05,FCB08}.  Under this interpretation, for example, one type {\em subtypes} another if the set of values it denotes is a {\em subset} of the other.  

We specify the meaning of types by formalising a set theoretic interpretation of them over the language of values given in Figure~\ref{c_types_abstract_values}.  To minimise confusion, care is taken in the figure to ensure that abstract values are represented canonically.  For example, ``${\tt 2\;/\;4}$'' is not a valid abstract value since ``${\tt 1\;/\;2}$'' is its canonical representation. Likewise, ``${\tt\{2,1\}}$'' is not a valid abstract value, with ``${\tt\{1,2\}}$'' being its canonical representation.   Figure~\ref{c_types_abstract_values} separates abstract values into distinct categories (e.g. integers, rationals, tuples, etc).  These distinctions are significant.  For example, ``${\tt 0}$'' is distinct \hl{How zero represented?}{from} ``${0\;/\;0}$''.  Similarly, byte values are not expressed using the digits ${\tt 0}$ and ${\tt 1}$ (as might be expected), but in terms of the characters ${\tt t}$ and ${\tt f}$.  This ensures binary values are distinct from integer values.

Finally, an evaluation function ${\tt\llbracket T\rrbracket}$ is defined which returns the set of values associated with a type ${\tt T}$.  For example, ${\tt\llbracket bool\rrbracket=\{true,false\}}$, ${\tt\llbracket int\rrbracket=\mathbb{Z}}$, etc.  In the remainder of this chapter, the body of this function will be give for each type as it is encountered.

\begin{figure}[!t]
\fbox{
\begin{minipage}{0.975\textwidth}
\begin{displaymath}
\begin{array}{rcllr}
{\tt v} & ::= & {\tt null} && \textrm{(null value)}\\
    & | & {\tt true}\;|\;{\tt false} & & \textrm{(boolean values)}\\
    & | & {\tt b} & {\tt\textrm{if}\;b\in\{t,f\}^8} & \textrm{(byte values)}\\
    & | & {\tt i} & {\tt \textrm{if}\;i\in\mathbb{Z}}& \textrm{(integer values)}\\
    & | & {\tt i\ /\ n} & {\tt \textrm{if}\;i\in\mathbb{Z}, n\in\mathbb{N}\;\textrm{and}\;\textrm{gcd}(i_1,i_2)=1} & \textrm{(rational values)}\\
    & | & \textrm{`}{\tt n}\textrm{'} & {\tt \textrm{if}\;n\in\mathbb{N}}& \textrm{(character values)}\\
    & | & {\tt (v_1,\ldots,v_n)} & & \textrm{(tuple values)}\\
    & | & {\tt \{v_1,\ldots,v_n\}} & {\tt \textrm{if}\;\forall i.v_i<v_{i+1}}& \textrm{(set values)}\\
    & | & {\tt \{v_1\Rightarrow v'_1,\ldots,v_n\Rightarrow v'_n\}} & {\tt \textrm{if}\;\forall i.v_i<v_{i+1}}& \textrm{(map values)}\\
    & | & {\tt [v_1,\ldots,v_n]} & & \textrm{(list values)}\\
    & | & {\tt \ell} & & \textrm{(locations)}\\
    &&\\
\end{array}
\end{displaymath}
\end{minipage}}
\caption{The language of abstract values used to formalise the meaning of types in Whiley, where $\mathbb{Z}$ is the (infinite) set of integers, $\mathbb{N}$ the (infinite) set of naturals and $\textrm{gcd()}$ returns the Greatest Common Divisor of two values (e.g. using Euclid's well-known algorithm).}
\label{c_types_abstract_values}
\end{figure}

\subsection{Type Descriptors}
\label{c_types_type_descriptors}
As discussed above, type descriptors provide syntax for describing types and, in the remaining sections of this chapter, we explore the range of types supported in Whiley.  The top-level grammar for type descriptors is:

\begin{syntax}
  \verb+Type+ & $::=$ & \verb+UnionType+ \\
              & $|$ & \verb+IntersectionType+ \\
              & $|$ & \verb+TermType+ \\
              &&\\
  \verb+TermType+ & $::=$ & \\
  & $|$ & \verb+PrimitiveType+ \\
  & $|$ & \verb+TupleType+ \\
  & $|$ & \verb+RecordType+ \\
  & $|$ & \verb+ReferenceType+ \\
  & $|$ & \verb+NominalType+ \\
  & $|$ & \verb+CollectionType+ \\
  & $|$ & \verb+NegationType+ \\
  & $|$ & \verb+FunctionType+ \\
  & $|$ & \verb+MethodType+ \\
\end{syntax}

\subsection{Type Patterns}
\label{c_types_type_patterns}

In Whiley, \gls{type_pattern}s are used to associate variables with types and their subcomponents.  For example, they can be used to declare variables and/or {\em destructuring} types into variables.  Type patterns are a source-level entity which are similar to type descriptors.  The top-level grammar for type patterns is:

\begin{syntax}
  \verb+TypePattern+ & $::=$ & \verb+Type+ \big[\ \verb+Ident+\ \big]\\
              & $|$ & \verb+TuplePattern+ \\
              & $|$ & \verb+RecordPattern+ \\
\end{syntax}

Type patterns do not exist for all compound structures --- only those where a value is guaranteed to exist which could be associated with a variable.

\section{Primitive Types}
\label{c_types_primitive_types}

\begin{syntax}
  \verb+PrimitiveType+ & $::=$ & \\
  & $|$ & \verb+AnyType+ \\
  & $|$ & \verb+VoidType+ \\
  & $|$ & \verb+NullType+ \\
  & $|$ & \verb+BoolType+ \\
  & $|$ & \verb+ByteType+ \\
  & $|$ & \verb+CharType+ \\
  & $|$ & \verb+IntType+ \\
  & $|$ & \verb+RealType+ \\
\end{syntax}

% =======================================================================
% Null
% =======================================================================

\subsection{Null}
\label{c_types_null}

The null type is a special type which should be used to show the absence of something. It is distinct from void, since variables can hold the special \lstinline{null} value (where as there is no special ``\lstinline{void}'' value).  Variables of \lstinline{null} type support only equality (\lstinline{==}) and inequality comparisons (\lstinline{!=}).  The \lstinline{null} value is particularly useful for representing optional values and terminating recursive types.

\begin{syntax}
  \verb+NullType+ & $::=$ & \token{null} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{null} type:

\begin{lstlisting}
type Tree is null | { int data, Tree left, Tree right }

function height(Tree t) => int:
    if t is null:
        // height of empty tree is zero
        return 0
    else:
        // height is this node plus maximum height of subtrees
        return 1 + Math.max(height(t.left), height(t.right))
\end{lstlisting}
This defines \lstinline{Tree} --- a {\em recursive type} --- which is either empty (i.e. \lstinline{null}) or consists of a field \lstinline{data} and two subtrees, \lstinline{left} and \lstinline{right}.  The \lstinline{height} function calculates the height of a \lstinline{Tree} as the longest path from the root through the tree.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{null} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
{\tt \llbracket null\rrbracket} & = & {\tt\{null\}}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{null} type is the singleton set containing exactly the \lstinline{null} value.


\paragraph{Notes.}  With all of the problems surrounding \lstinline{null} and \lstinline{NullPointerException}s in languages like Java and C, it may seem that this type should be avoided. However, it remains a very useful abstraction around (e.g. for terminating recursive types) and, in Whiley, is treated in a completely safe manner (unlike e.g. Java).

% =======================================================================
% Bool 
% =======================================================================

\subsection{Booleans}
\label{c_types_bool}

The \lstinline{bool} type represents the set of boolean values (i.e. \lstinline{true} and \lstinline{false}).  Variables of \lstinline{bool} type support equality (\lstinline{==}), inequality (\lstinline{!=}), logical and (\lstinline{&&}), logical or (\lstinline{||}), logical xor (\lstinline{^}) and logical not (\lstinline{!}).

\begin{syntax}
 \verb+BoolType+ & $::=$ & \token{bool} \\
\end{syntax}

\paragraph{Examples.} The following illustrates a simple example of the \lstinline{bool} type:

\begin{lstlisting}
// Determine whether item is contained in list or not
function contains([int] list, int item) => bool:
    // examine every element of list
    for l in list:
        if l == item:
            return true
    // done
    return false
\end{lstlisting}
This function determines whether or not a given integer value is contained within a list of integers.  If so, it returns \lstinline{true}, otherwise it returns \lstinline{false}.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{bool} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
{\tt\llbracket bool\rrbracket} & = & {\tt\{ true, false\}}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{bool} type is the set containing exactly the values \lstinline{true} and \lstinline{false}.

% =======================================================================
% Byte
% =======================================================================

\subsection{Bytes}
\label{c_types_byte}

The type \lstinline{byte} represents the set of eight-bit sequences, whose values are expressed numerically using \lstinline{0} and \lstinline{1} followed by \lstinline{b} (e.g. 00101b).  Variables of \lstinline{byte} type support equality (\lstinline{==}), inequality (\lstinline{!=}), bitwise and (\lstinline{&}), bitwise or (\lstinline{|}), bitwise xor (\lstinline{^}), bitwise complement (\lstinline{~}), left shift (\lstinline{<<}) and right shift (\lstinline{>>}).

\begin{syntax}
 \verb+ByteType+ & $::=$ & \token{byte}\\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{byte} type:

\begin{lstlisting}
// convert a byte into a string
function toString(byte b) => string:
    string r = "b"
    for i in 0..8:
        if (b & 00000001b) == 00000001b:
            r = "1" ++ r
        else:
            r = "0" ++ r
        b = b >> 1	
    return r
\end{lstlisting}
This illustrates the conversion from a \lstinline{byte} into a \lstinline{string}.  The conversion is performed one digit at a time, starting from the rightmost bit.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{byte} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
{\tt\llbracket byte\rrbracket} & = & {\tt\{\;b\;|\;b\in\{t,f\}^8\;\}}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{byte} type is the set of all 256 possible combinations of eight-bit sequences.

\paragraph{Notes.}  Unlike for many languages, there is no representation associated with a byte. For example, to extract an integer value from a byte, it must be explicitly decoded according to some representation (e.g. two's compliment) using an auxillary function (e.g. \lstinline{Byte.toInt()}).


% =======================================================================
% Int
% =======================================================================

\subsection{Integers}
\label{c_types_int}

The type \lstinline{int} represents the set of arbitrary-sized integers, whose values are expressed as a sequence of one or more numerical or hexadecimal digits (e.g. \lstinline{123456}, \lstinline{0xffaf}, etc).  Variables of \lstinline{int} type support equality (\lstinline{==}), inequality (\lstinline{!=}), comparators (\lstinline{<},\lstinline{<=},\lstinline{>=},\lstinline{>}), addition (\lstinline{+}), subtraction (\lstinline{-}), multiplication (\lstinline{*}), division (\lstinline{/}), remainder (\lstinline{%}) and negation (\lstinline{-}) operations.


\begin{syntax}
  \verb+IntType+ & $::=$ & \token{int} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{int} type:

\begin{lstlisting}
function fib(int x) => int:
    if x <= 1:
        return x
    else:
        return fib(x-1) + fib(x-2)
\end{lstlisting}
This illustrates the well-known recursive method for computing numbers in the {\em fibonacci} sequence.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{int} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
{\tt\llbracket int\rrbracket} & = & {\tt\mathbb{Z}}\\
\end{array}
\end{displaymath}
In other words, the of values defined by the type \lstinline{int} is exactly the (infinite) set of integers.

\paragraph{Notes.}  Since integers in Whiley are of arbitrary size, {\em integer overflow} is not possible.  This contrasts with other languages (e.g. Java) that used {\em fixed-width} number representations (e.g. 32bit two's complement).  Furthermore, there is nothing equivalent to the constants found in such languages for representing the uppermost and least integers expressible (e.g. \lstinline{Integer.MIN_VALUE} and \lstinline{Integer.MAX_VALUE}, as found in Java).
% =======================================================================
% Real
% =======================================================================

\subsection{Rationals}
\label{c_types_real}

The type \lstinline{real} represents the set of arbitrary-sized rationals, whose values are expressed as a sequence of one or more numerical digits separated by a period (e.g. \lstinline{1.0}, \lstinline{0.223}, \lstinline{12.55}, etc).  Variables of \lstinline{real} type support equality (\lstinline{==}), inequality (\lstinline{!=}), comparators (\lstinline{<},\lstinline{<=},\lstinline{>=},\lstinline{>}), addition (\lstinline{+}), subtraction (\lstinline{-}), multiplication (\lstinline{*}), division (\lstinline{/}), remainder (\lstinline{%}) and negation (\lstinline{-}) operations.  Variables of type \lstinline{real} also support the {\em rational destructuring assignment} to extract the numerator and denominator (illustrated below).

\begin{syntax}
  \verb+RealType+ & $::=$ & \token{real} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{real} type:

\begin{lstlisting}
function floor(real x) => int:
    int num / int den = x    // extract numerator and denominator
    int r = num / den        // integer division
    if x < 0.0 && den != 1: 	 
        return r - 1 
    else:
        return r 
\end{lstlisting}
This illustrates the well-known function for computing the {\em floor} of a \lstinline{real} variable \lstinline{x} (i.e. the greatest integer not larger than \lstinline{x}).  The rational destructuring assignment is used to extract the numerator and denominator of the parameter \lstinline{x}.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{real} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
{\tt \llbracket real\rrbracket} & = & {\tt\{ v_n / v_d \;|\;v_n\in\mathbb{Z},v_d\in\mathbb{Z}\}}\\
\end{array}
\end{displaymath}
In other words, the of values defined by the type \lstinline{real} is the (infinite) set of all integer pairs, where the first element is designated the numerator, and the second designated the denominator.

% =======================================================================
% Char
% =======================================================================

\subsection{Characters}
\label{c_types_char}

The type \lstinline{char} represents the set of unicode characters, whose values are expressed as an arbitrary character between quotes (e.g. \lstinline{'c'}, \lstinline{'0'}, \lstinline{'%'}, etc).  Variables of \lstinline{char} type support equality (\lstinline{==}), inequality (\lstinline{!=}), comparators (\lstinline{<},\lstinline{<=},\lstinline{>=},\lstinline{>}), addition (\lstinline{+}), subtraction (\lstinline{-}), multiplication (\lstinline{*}), division (\lstinline{/}), remainder (\lstinline{%}) and negation (\lstinline{-}) operations.

\begin{syntax}
  \verb+CharType+ & $::=$ & \token{char} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{char} type:

\begin{lstlisting}
function isUpperCase(char c) => bool:
    return 'A' <= c && c <= 'Z'
\end{lstlisting}
This illustrates a very simple function for determining whether an ASCII character is uppercase or not.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{int} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
{\tt\llbracket char\rrbracket} & = & {\tt\mathbb{Z}}\\
\end{array}
\end{displaymath}
In other words, the of values defined by the type \lstinline{char} is exactly the (infinite) set of integers.

% =======================================================================
% Any
% =======================================================================

\subsection{Any}
\label{c_types_any}

The type \lstinline{any} represents the type whose variables may hold any possible value.  Thus, \lstinline{any} is the {\em top type} (i.e. $\top$) in the lattice of types and, hence, is the supertype of all other types.  Variables of \lstinline{any} type support only equality (\lstinline{==}) and inequality comparisons (\lstinline{!=}) as well as {\em runtime type tests}.  Finally, unlike the majority of other types, there are no {\em values} of type \lstinline{any}.

\begin{syntax}
  \verb+AnyType+ & $::=$ & \token{any} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{any} type:

\begin{lstlisting}
function toInt(any val) => int:
    if val is int:
        return val
    else if val is real:
        return Math.floor(val)
    else:
        return 0 // default value        
\end{lstlisting}

Here, the function \lstinline{toInt} accepts {\em any valid Whiley value}, which includes all values of type \lstinline{int}, \lstinline{real}, collections, records, etc.  The function then inspects the value that it has been passed and, in the case of values of type \lstinline{int} and \lstinline{real}, returns an integer approximation; for all other values, it returns \lstinline{0}.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{any} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
{\tt\llbracket any\rrbracket} & = & \mathcal{D}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{any} type equals the {\em domain} (i.e. the set of all values).

\paragraph{Notes.}  The any type is roughly comparable to the \lstinline{Object} type found in pure object-oriented languages.  However, in impure object-oriented languages which support primitive types, such as Java, this comparison often falls short because \lstinline{Object} is not a supertype of primitives such as \lstinline{int} or \lstinline{long}.

% =======================================================================
% Void 
% =======================================================================

\subsection{Void}
\label{c_types_void}

The \lstinline{void} type represents the type whose variables cannot exist (i.e. because they cannot hold any possible value).  Thus, \lstinline{void} is the {\em bottom type} (i.e. $\bot$) in the lattice of types and, hence, is the {\em subtype} of all other types.  Void is used to represent the return type of a method which does not return anything.  Furthermore, it is also used to represent the element type of an empty list of set.  Finally, unlike the majority of other types, there are no {\em values} of type \lstinline{void}.

\begin{syntax}
   \verb+VoidType+ & $::=$ & \token{void} \\
\end{syntax}

\paragraph{Examples.} The following example illustrates several uses of the \lstinline{void} type:

\begin{lstlisting}
// Attempt to update first element
method update1st(&[int] list, int value) => void:
    // First, check whether list is empty or not
    if *list != [void]:
       // Then, update 1st element
       (*list)[0] = x
    // done
\end{lstlisting}

Here, the method \lstinline{update1st} is declared to return
\lstinline{void} --- meaning it does not return a value.  Instead,
this method updates some existing state accessible through the
reference \lstinline{list}.  Within the method body, the value
accessible via this reference is compared against the
\lstinline{[void]} (i.e. the {\em empty list}).

\paragraph{Semantics.}  The set of values defined by the type
\lstinline{void} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
{\tt\llbracket void\rrbracket} & = & \emptyset\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{void} type
equals the empty set.  

% =======================================================================
% Tuples
% =======================================================================

\section{Tuples}
\label{c_types_tuple}

A tuple type describes a compound type made up of two or more elements in sequence, whose values are expressed as sequences of values separated by a comma (e.g. \lstinline{1,2}, \lstinline{2.0,3.32,3.45}, etc).  Tuples are similar to records, except that fields are effectively anonymous.  Variables of tuple type support equality (\lstinline{==}) and inequality (\lstinline{!=}) operations, as well the {\em tuple destructuring assignment} to extract elements (illustrated below).

\begin{syntax}
  \verb+TupleType+ & $::=$ & \token{(}\ \verb+Type+\ \big(\ \token{,}\
  \verb+Type+\ \big)$^+$\ \token{)}\\
  &&\\
  \verb+TuplePattern+ & $::=$ & \token{(}\ \verb+TypePattern+\ \big(\ \token{,}\
  \verb+TypePattern+\ \big)$^+$\ \token{)}\ \big[\ \verb+Ident+\ \big]\\
\end{syntax}

\paragraph{Examples.} The following example illustrates several uses of tuples:

\begin{lstlisting}
function swap(int x, int y) => (int,int):
    return y,x
\end{lstlisting}
This function accepts two integer parameters, and returns a tuple type containing two integers.  The function simple reverses the order that the values occur in the tuple passed as a parameter.

\paragraph{Semantics.}  The set of values defined by a tuple type is given as follows:
\begin{displaymath}
\begin{array}{rcl}
{\tt \llbracket(T_1, \ldots, T_n)\rrbracket} & = & {\tt\{ v_1,\ldots,v_n\;|\;v_1\in\llbracket T_1\rrbracket, \ldots, v_n\in\llbracket T_n\rrbracket\}}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{void} type
equals the empty set.  

% =======================================================================
% Records
% =======================================================================

\section{Records}
\label{c_types_record}

A record is made up of a number of fields, each of which has a unique name. Each field has a corresponding type. One can think of a record as a special kind of "fixed" map (i.e. where we know exactly which entries we have).

\begin{syntax}
  \verb+RecordType+ & $::=$ & \token{\{}\ \verb+Type+\
  \verb+Ident+\ \big(\ \token{,}\ \verb+Type+\ \verb+Ident+\
  \big)$^*$ \big[\ \token{,}\ \token{...}\ \big]\ \token{\}}\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  Syntax for functions?  Open versus closed records?

% =======================================================================
% References
% =======================================================================

\section{References}

Represents a reference to an object in Whiley.

\begin{syntax}
  \verb+ReferenceType+ & $::=$ & \token{\&}\ \ \verb+Type+\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Nominal
% =======================================================================

\section{Nominals}
\label{c_types_nominal}

The existential type represents the an unknown type, defined at a given position.

\begin{syntax}
  \verb+NominalType+ & $::=$ & \verb+Ident+\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Collections
% =======================================================================

\section{Collections}
\label{c_types_collection}

% =======================================================================
% Set
% =======================================================================

\subsection{Sets}
\label{c_types_set}

A set type describes set values whose elements are subtypes of the element type. For example, \lstinline|{1,2,3}| is an instance of set type \lstinline|{int}|; however, \lstinline|{1.345}| is not.

\begin{syntax}
  \verb+SetType+ & $::=$ & \token{\{} \ \verb+Type+ \ \token{\}} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Map
% =======================================================================

\subsection{Maps}
\label{c_types_map}

A map represents a one-many mapping from variables of one type to variables of another type. For example, the map type \lstinline|{int=>real}| represents a map from integers to real values. A valid instance of this type might be \lstinline|{1=>1.2,2=>3.0}|.

\begin{syntax}
  \verb+MapType+ & $::=$ & \token{\{} \ \verb+Type+ \ \token{=>} \ \verb+Type+ \ \token{\}} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% List
% =======================================================================

\subsection{Lists}
\label{c_types_list}

A list type describes list values whose elements are subtypes of the element type. For example, \lstinline{[1,2,3]} is an instance of list type \lstinline{[int]}; however, \lstinline{[1.345]} is not.

\begin{syntax}
  \verb+ListType+ & $::=$ & \token{[} \ \verb+Type+ \ \token{]}\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Functions
% =======================================================================

\section{Functions}

\begin{syntax}
  \verb+FunctionType+ & $::=$ & \token{function}\ \token{(}\
  \big[\ \verb+Type+\ \big(\ \token{,}\ \verb+Type+\ \big)$^*$\ \big]\ \token{)}\ \token{=>}\ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Functions
% =======================================================================

\section{Methods}

\begin{syntax}
  \verb+MethodType+ & $::=$ & \token{method}\ \token{(}\
  \big[\ \verb+Type+\ \big(\ \token{,}\ \verb+Type+\ \big)$^*$\ \big]\ \token{)}\ \token{=>}\ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Unions
% =======================================================================

\section{Unions}
\label{c_types_unions}

A union type represents a type whose variables may hold values from any of its "bounds". For example, the union type \lstinline{null|int} indicates a variable can either hold an integer value, or \lstinline{null}. 

\begin{syntax}
  \verb+UnionType+ & $::=$ & \verb+IntersectionType+\ \big(\ \token{|}\ \verb+IntersectionType+\
  \big)$^*$\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  There must be at least two bounds for a union type to make sense.

% =======================================================================
% Intersections
% =======================================================================

\section{Intersections}
\label{c_types_intersections}

\begin{syntax}
  \verb+IntersectionType+ & $::=$ & \verb+TermType+\ \big(\ \token{\&}\ \verb+TermType+\
  \big)$^*$\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Negations
% =======================================================================

\section{Negations}
\label{c_types_negations}

\begin{syntax}
  NegationType & $::=$ & \token{!}\ \ \verb+TermType+\\
\end{syntax}

\paragraph{Description.}  A negation type represents a type which
accepts values {\em not} in a given type.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

\section{Abstract Types}
\subsection{Recursive Types}
\subsection{Effective Tuples}
\subsection{Effective Records}
\subsection{Effective Collections}

\section{Subtyping Algorithms}
Discussion of soundness and completeness.

\section{Equivalences}
Discuss some obvious equivalences between types.
