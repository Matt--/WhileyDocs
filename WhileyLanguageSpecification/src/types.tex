\chapter{Types \& Values}
\section{Overview}
Discuss syntactic versus semantic types, as well as the set of all values.  Probably discuss the different kinds of values which are possible, and the fact that every value has a single {\em concrete} type associate with it.  Also, need to consider constrained types as well as type patterns.

\begin{syntax}
  \verb+Type+ & $::=$ & \\
  & $|$ & \verb+TermType+ \\
  & $|$ & \verb+UnionType+ \\
  & $|$ & \verb+IntersectionType+ \\
\end{syntax}

\begin{syntax}
  \verb+TermType+ & $::=$ & \\
  & $|$ & \verb+PrimitiveType+ \\
  & $|$ & \verb+TupleType+ \\
  & $|$ & \verb+RecordType+ \\
  & $|$ & \verb+ReferenceType+ \\
  & $|$ & \verb+NominalType+ \\
  & $|$ & \verb+CollectionType+ \\
  & $|$ & \verb+NegationType+ \\
  & $|$ & \verb+FunctionType+ \\
  & $|$ & \verb+MethodType+ \\
\end{syntax}


\section{Primitives}

\begin{syntax}
  \verb+PrimitiveType+ & $::=$ & \\
  & $|$ & \verb+AnyType+ \\
  & $|$ & \verb+VoidType+ \\
  & $|$ & \verb+NullType+ \\
  & $|$ & \verb+BoolType+ \\
  & $|$ & \verb+ByteType+ \\
  & $|$ & \verb+CharType+ \\
  & $|$ & \verb+IntType+ \\
  & $|$ & \verb+RealType+ \\
\end{syntax}


% =======================================================================
% Null
% =======================================================================

\subsection{Null}

The null type is a special type which should be used to show the absence of something. It is distinct from void, since variables can hold the special \lstinline{null} value (where as there is no special ``\lstinline{void}'' value).  Variables of \lstinline{null} type support only equality (\lstinline{==}) and inequality comparisons (\lstinline{!=}).  The \lstinline{null} value is particularly useful for representing optional values and terminating recursive types.

\begin{syntax}
  \verb+NullType+ & $::=$ & \token{null} \\
  &&\\
  \verb+NullValue+ & $::=$ & \token{null} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{null} type:

\begin{lstlisting}
type Tree is null | { int data, Tree left, Tree right }

function height(Tree t) => int:
    if t is null:
        // height of empty tree is zero
        return 0
    else:
        // height is this node plus maximum height of subtrees
        return 1 + Math.max(height(t.left), height(t.right))
\end{lstlisting}
This defines \lstinline{Tree} --- a {\em recursive type} --- which is either empty (i.e. \lstinline{null}) or consists of a field \lstinline{data} and two subtrees, \lstinline{left} and \lstinline{right}.  The \lstinline{height} function calculates the height of a \lstinline{Tree} as the longest path from the root through the tree.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{null} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt null}\rrbracket & = & \{{\tt null}\}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{null} type is the singleton set containing exactly the \lstinline{null} value.


\paragraph{Notes.}  With all of the problems surrounding \lstinline{null} and \lstinline{NullPointerException}s in languages like Java and C, it may seem that this type should be avoided. However, it remains a very useful abstraction around (e.g. for terminating recursive types) and, in Whiley, is treated in a completely safe manner (unlike e.g. Java).

% =======================================================================
% Bool 
% =======================================================================

\subsection{Booleans}

The \lstinline{bool} type represents the set of boolean values (i.e. \lstinline{true} and \lstinline{false}).  Variables of \lstinline{bool} type support equality (\lstinline{==}), inequality (\lstinline{!=}), logical and (\lstinline{&&}), logical or (\lstinline{||}), logical xor (\lstinline{^}) and logical not (\lstinline{!}).

\begin{syntax}
 \verb+BoolType+ & $::=$ & \token{bool} \\
&&\\
\verb+BoolValue+ & $::=$ & \token{true} $|$ \token{false} \\
\end{syntax}

\paragraph{Examples.} The following illustrates a simple example of the \lstinline{bool} type:

\begin{lstlisting}
// Determine whether item is contained in list or not
function contains([int] list, int item) => bool:
    // examine every element of list
    for l in list:
        if l == item:
            return true
    // done
    return false
\end{lstlisting}
This function determines whether or not a given integer value is contained within a list of integers.  If so, it returns \lstinline{true}, otherwise it returns \lstinline{false}.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{bool} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt bool}\rrbracket & = & \{{\tt true},{\tt false}\}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{bool} type is the set containing exactly the values \lstinline{true} and \lstinline{false}.

% =======================================================================
% Byte
% =======================================================================

\subsection{Bytes}

The type \lstinline{byte} represents the set of eight-bit sequences, whose values are expressed numerically using \lstinline{0} and \lstinline{1} followed by \lstinline{b} (e.g. 00101b).  Variables of \lstinline{byte} type support equality (\lstinline{==}), inequality (\lstinline{!=}), bitwise and (\lstinline{&}), bitwise or (\lstinline{|}), bitwise xor (\lstinline{^}), bitwise complement (\lstinline{~}), left shift (\lstinline{<<}) and right shift (\lstinline{>>}).

\begin{syntax}
 \verb+ByteType+ & $::=$ & \token{byte}\\
 &&\\
 \verb+ByteValue+ & $::=$ & \big(\ \token{0}\ $|$\ \token{1}\ \big)$^+$\ \token{b}\\
\end{syntax}

Byte values do not need to contain exactly eight digits and, when fewer digits are given, are padded out to eight digits by appending zero's from the left (e.g. \lstinline{00101b} becomes \lstinline{00101b}).

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{byte} type:

\begin{lstlisting}
// convert a byte into a string
function toString(byte b) => string:
    r = "b"
    for i in 0..8:
        if (b & 00000001b) == 00000001b:
            r = "1" ++ r
        else:
            r = "0" ++ r
        b = b >> 1	
    return r
\end{lstlisting}
This illustrates the conversion from a \lstinline{byte} into a \lstinline{string}.  The conversion is performed one digit at a time, starting from the rightmost bit.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{byte} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt byte}\rrbracket & = & \{???\}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{byte} type is the set of all 256 possible combinations of eight-bit sequences.

\paragraph{Notes.}  Unlike for many languages, there is no
representation associated with a byte. For example, to extract an
integer value from a byte, it must be explicitly decoded according to
some representation (e.g. two's compliment) using an auxillary function (e.g. \lstinline{Byte.toInt()}).


% =======================================================================
% Int
% =======================================================================

\subsection{Integers}

The type \lstinline{int} represents the set of arbitrary-sized integers, whose values are expressed as a sequence of one or more numerical or hexadecimal digits (e.g. \lstinline{123456}, \lstinline{0xffaf}, etc).  Variables of \lstinline{int} type support equality (\lstinline{==}), inequality (\lstinline{!=}), comparators (\lstinline{<},\lstinline{<=},\lstinline{>=},\lstinline{>}), addition (\lstinline{+}), subtraction (\lstinline{-}), multiplication (\lstinline{*}), division (\lstinline{/}), remainder (\lstinline{%}) and negation (\lstinline{-}) operations.


\begin{syntax}
  \verb+IntType+ & $::=$ & \token{int} \\
  &&\\
  \verb+IntValue+ & $::=$ & \big( \token{0}\ $|$\ \ldots\ $|$\ \token{9}\ \big)$^+$ \\
  & $|$ & \token{0} \token{x}\ \big( \token{0}\ $|$\ \ldots\ $|$\ \token{9}\ $|$\ \token{a}\ $|$\ \ldots\ $|$\ \token{f}\ $|$\ \token{A}\ $|$\ \ldots\ $|$\ \token{F}\ \big)$^+$\\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{int} type:

\begin{lstlisting}
function fib(int x) => int:
    if x <= 1:
        return x
    else:
        return fib(x-1) + fib(x-2)
\end{lstlisting}
This illustrates the well-known recursive method for computing numbers in the {\em fibonacci} sequence.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{int} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt int}\rrbracket & = & \mathbb{Z}\\
\end{array}
\end{displaymath}
In other words, the of values defined by the type \lstinline{int} is exactly the (infinite) set of integers.

\paragraph{Notes.}  Since integers in Whiley are of arbitrary size, {\em integer overflow} is not possible.  This contrasts with other languages (e.g. Java) that used {\em fixed-width} number representations (e.g. 32bit two's complement).  Furthermore, there is nothing equivalent to the constants found in such languages for representing the uppermost and least integers expressible (e.g. \lstinline{Integer.MIN_VALUE} and \lstinline{Integer.MAX_VALUE}, as found in Java).
% =======================================================================
% Real
% =======================================================================

\subsection{Rationals}

The type \lstinline{real} represents the set of arbitrary-sized rationals, whose values are expressed as a sequence of one or more numerical digits separated by a period (e.g. \lstinline{1.0}, \lstinline{0.223}, \lstinline{12.55}, etc).  Variables of \lstinline{real} type support equality (\lstinline{==}), inequality (\lstinline{!=}), comparators (\lstinline{<},\lstinline{<=},\lstinline{>=},\lstinline{>}), addition (\lstinline{+}), subtraction (\lstinline{-}), multiplication (\lstinline{*}), division (\lstinline{/}), remainder (\lstinline{%}) and negation (\lstinline{-}) operations.  Variables of type \lstinline{real} also support the {\em rational destructuring assignment} to extract the numerator and denominator (illustrated below).

\begin{syntax}
  \verb+RealType+ & $::=$ & \token{real} \\
  &&\\
  \verb+RealValue+ & $::=$ & \big( \token{0}\ $|$\ \ldots\ $|$\ \token{9}\ \big)$^+$\ \token{.}\ \big( \token{0}\ $|$\ \ldots\ $|$\ \token{9}\ \big)$^+$ \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{real} type:

\begin{lstlisting}
function floor(real x) => int:
    int num / int den = x    // extract numerator and denominator
    int r = num / den        // integer division
    if x < 0.0 && den != 1: 	 
        return r - 1 
    else:
        return r 
\end{lstlisting}
This illustrates the well-known function for computing the {\em floor} of a \lstinline{real} variable \lstinline{x} (i.e. the greatest integer not larger than \lstinline{x}).  The rational destructuring assignment is used to extract the numerator and denominator of the parameter \lstinline{x}.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{real} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt real}\rrbracket & = & \mathbb{Z}\times\mathbb{Z}\\
\end{array}
\end{displaymath}
In other words, the of values defined by the type \lstinline{real} is the (infinite) set of all integer pairs, where the first element represents the numerator, and the second represents the denominator.

% =======================================================================
% Char
% =======================================================================

\subsection{Characters}

The type \lstinline{char} represents the set of unicode characters, whose values are expressed as an arbitrary character between quotes (e.g. \lstinline{'c'}, \lstinline{'0'}, \lstinline{'%'}, etc).  Variables of \lstinline{char} type support equality (\lstinline{==}), inequality (\lstinline{!=}), comparators (\lstinline{<},\lstinline{<=},\lstinline{>=},\lstinline{>}), addition (\lstinline{+}), subtraction (\lstinline{-}), multiplication (\lstinline{*}), division (\lstinline{/}), remainder (\lstinline{%}) and negation (\lstinline{-}) operations.

\begin{syntax}
  \verb+CharType+ & $::=$ & \token{char} \\
  &&\\
  \verb+CharValue+ & $::=$ & \token{'}\ .\ \token{'} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{char} type:

\begin{lstlisting}
function isUpperCase(char c) => bool:
    return 'A' <= c && c <= 'Z'
\end{lstlisting}
This illustrates a very simple function for determining whether an ASCII character is uppercase or not.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{int} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt char}\rrbracket & = & \mathbb{Z}\\
\end{array}
\end{displaymath}
In other words, the of values defined by the type \lstinline{char} is exactly the (infinite) set of integers.

% =======================================================================
% Any
% =======================================================================

\subsection{Any}

The type \lstinline{any} represents the type whose variables may hold any possible value.  Thus, \lstinline{any} is the {\em top type} (i.e. $\top$) in the lattice of types and, hence, is the supertype of all other types.  Variables of \lstinline{any} type support only equality (\lstinline{==}) and inequality comparisons (\lstinline{!=}) as well as {\em runtime type tests}.  Finally, unlike the majority of other types, there are no {\em values} of type \lstinline{any}.

\begin{syntax}
  \verb+AnyType+ & $::=$ & \token{any} \\
\end{syntax}

\paragraph{Examples.}  The following illustrates a simple example of the \lstinline{any} type:

\begin{lstlisting}
function toInt(any val) => int:
    if val is int:
        return val
    else if val is real:
        return Math.floor(val)
    else:
        return 0 // default value        
\end{lstlisting}

Here, the function \lstinline{toInt} accepts {\em any valid Whiley value}, which includes all values of type \lstinline{int}, \lstinline{real}, collections, records, etc.  The function then inspects the value that it has been passed and, in the case of values of type \lstinline{int} and \lstinline{real}, returns an integer approximation; for all other values, it returns \lstinline{0}.

\paragraph{Semantics.}  The set of values defined by the type \lstinline{any} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt any}\rrbracket & = & \mathcal{D}\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{any} type equals the {\em domain} (i.e. the set of all values).

\paragraph{Notes.}  The any type is roughly comparable to the \lstinline{Object} type found in pure object-oriented languages.  However, in impure object-oriented languages which support primitive types, such as Java, this comparison often falls short because \lstinline{Object} is not a supertype of primitives such as \lstinline{int} or \lstinline{long}.

% =======================================================================
% Void 
% =======================================================================

\subsection{Void}

The \lstinline{void} type represents the type whose variables cannot exist (i.e. because they cannot hold any possible value).  Thus, \lstinline{void} is the {\em bottom type} (i.e. $\bot$) in the lattice of types and, hence, is the {\em subtype} of all other types.  Void is used to represent the return type of a method which does not return anything.  Furthermore, it is also used to represent the element type of an empty list of set.  Finally, unlike the majority of other types, there are no {\em values} of type \lstinline{void}.

\begin{syntax}
   \verb+VoidType+ & $::=$ & \token{void} \\
\end{syntax}

\paragraph{Examples.} The following example illustrates several uses of the \lstinline{void} type:

\begin{lstlisting}
// Attempt to update first element
method update1st(&[int] list, int value) => void:
    // First, check whether list is empty or not
    if *list != [void]:
       // Then, update 1st element
       (*list)[0] = x
    // done
\end{lstlisting}

Here, the method \lstinline{update1st} is declared to return
\lstinline{void} --- meaning it does not return a value.  Instead,
this method updates some existing state accessible through the
reference \lstinline{list}.  Within the method body, the value
accessible via this reference is compared against the
\lstinline{[void]} (i.e. the {\em empty list}).

\paragraph{Semantics.}  The set of values defined by the type
\lstinline{void} is given as follows:
\begin{displaymath}
\begin{array}{rcl}
\llbracket{\tt void}\rrbracket & = & \emptyset\\
\end{array}
\end{displaymath}
In other words, the set of values defined by the \lstinline{void} type
equals the empty set.  

% =======================================================================
% Tuples
% =======================================================================

\section{Tuples}

A tuple type describes a compound type made up of two or more subcomponents. It is similar to a record, except that fields are effectively anonymous.

\begin{syntax}
  \verb+TupleType+ & $::=$ & \token{(}\ \verb+Type+\ \big(\ \token{,}\
  \verb+Type+\ \big)$^+$\ \token{)}\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Records
% =======================================================================

\section{Records}

A record is made up of a number of fields, each of which has a unique name. Each field has a corresponding type. One can think of a record as a special kind of "fixed" map (i.e. where we know exactly which entries we have).

\begin{syntax}
  \verb+RecordType+ & $::=$ & \token{\{}\ \verb+Type+\
  \verb+Ident+\ \big(\ \token{,}\ \verb+Type+\ \verb+Ident+\
  \big)$^*$ \big[\ \token{,}\ \token{...}\ \big]\ \token{\}}\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  Syntax for functions?  Open versus closed records?

% =======================================================================
% References
% =======================================================================

\section{References}

Represents a reference to an object in Whiley.

\begin{syntax}
  \verb+ReferenceType+ & $::=$ & \token{\&}\ \ \verb+Type+\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Nominal
% =======================================================================

\section{Nominals}

The existential type represents the an unknown type, defined at a given position.

\begin{syntax}
  \verb+NominalType+ & $::=$ & \verb+Ident+\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Collections
% =======================================================================

\section{Collections}

% =======================================================================
% Set
% =======================================================================

\subsection{Sets}

A set type describes set values whose elements are subtypes of the element type. For example, \lstinline|{1,2,3}| is an instance of set type \lstinline|{int}|; however, \lstinline|{1.345}| is not.

\begin{syntax}
  \verb+SetType+ & $::=$ & \token{\{} \ \verb+Type+ \ \token{\}} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Map
% =======================================================================

\subsection{Maps}

A map represents a one-many mapping from variables of one type to variables of another type. For example, the map type \lstinline|{int=>real}| represents a map from integers to real values. A valid instance of this type might be \lstinline|{1=>1.2,2=>3.0}|.

\begin{syntax}
  \verb+MapType+ & $::=$ & \token{\{} \ \verb+Type+ \ \token{=>} \ \verb+Type+ \ \token{\}} \\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% List
% =======================================================================

\subsection{Lists}

A list type describes list values whose elements are subtypes of the element type. For example, \lstinline{[1,2,3]} is an instance of list type \lstinline{[int]}; however, \lstinline{[1.345]} is not.

\begin{syntax}
  \verb+ListType+ & $::=$ & \token{[} \ \verb+Type+ \ \token{]}\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Functions
% =======================================================================

\section{Functions}

\begin{syntax}
  \verb+FunctionType+ & $::=$ & \token{function}\ \token{(}\
  \big[\ \verb+Type+\ \big(\ \token{,}\ \verb+Type+\ \big)$^*$\ \big]\ \token{)}\ \token{=>}\ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Functions
% =======================================================================

\section{Methods}

\begin{syntax}
  \verb+MethodType+ & $::=$ & \token{method}\ \token{(}\
  \big[\ \verb+Type+\ \big(\ \token{,}\ \verb+Type+\ \big)$^*$\ \big]\ \token{)}\ \token{=>}\ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Unions
% =======================================================================

\section{Unions}

A union type represents a type whose variables may hold values from any of its "bounds". For example, the union type \lstinline{null|int} indicates a variable can either hold an integer value, or \lstinline{null}. 

\begin{syntax}
  \verb+UnionType+ & $::=$ & \verb+IntersectionType+\ \big(\ \token{|}\ \verb+IntersectionType+\
  \big)$^+$\\
\end{syntax}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  There must be at least two bounds for a union type to make sense.

% =======================================================================
% Intersections
% =======================================================================

\section{Intersections}

\begin{syntax}
  \verb+IntersectionType+ & $::=$ & \verb+TermType+\ \big(\ \token{\&}\ \verb+TermType+\
  \big)$^+$\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Negations
% =======================================================================

\section{Negations}

\begin{syntax}
  NegationType & $::=$ & \token{!}\ \ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  A negation type represents a type which
accepts values {\em not} in a given type.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

\section{Abstract Types}
\subsection{Recursive Types}
\subsection{Effective Tuples}
\subsection{Effective Records}
\subsection{Effective Collections}

\section{Subtyping Algorithms}
Discussion of soundness and completeness.

\section{Equivalences}
Discuss some obvious equivalences between types.
