\chapter{Types}
\section{Overview}
Discuss syntactic versus semantic types.  Also, need to consider
constrained types as well as type patterns.

\begin{syntax}
  \verb+Type+ & $::=$ & \\
  & $|$ & \verb+TermType+ \\
  & $|$ & \verb+UnionType+ \\
  & $|$ & \verb+IntersectionType+ \\
\end{syntax}

\begin{syntax}
  \verb+TermType+ & $::=$ & \\
  & $|$ & \verb+PrimitiveType+ \\
  & $|$ & \verb+TupleType+ \\
  & $|$ & \verb+RecordType+ \\
  & $|$ & \verb+ReferenceType+ \\
  & $|$ & \verb+NominalType+ \\
  & $|$ & \verb+CollectionType+ \\
  & $|$ & \verb+NegationType+ \\
  & $|$ & \verb+FunctionType+ \\
  & $|$ & \verb+MethodType+ \\
\end{syntax}


\section{Primitives}

\begin{syntax}
  \verb+PrimitiveType+ & $::=$ & \\
  & $|$ & \verb+AnyType+ \\
  & $|$ & \verb+VoidType+ \\
  & $|$ & \verb+NullType+ \\
  & $|$ & \verb+BoolType+ \\
  & $|$ & \verb+ByteType+ \\
  & $|$ & \verb+CharType+ \\
  & $|$ & \verb+IntType+ \\
  & $|$ & \verb+RealType+ \\
\end{syntax}


% =======================================================================
% Any
% =======================================================================

\subsection{Any Type}

\begin{syntax}
  \verb+AnyType+ & $::=$ & \token{any} \\
\end{syntax}

\paragraph{Description.}  The type \lstinline{any} represents the type whose variables may hold any possible value.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} The \lstinline{any} type is top in the type
lattice.  That is, it is the supertype of all other types.

% =======================================================================
% Void 
% =======================================================================

\subsection{Void Type}

\begin{syntax}
   \verb+VoidType+ & $::=$ & \token{void} \\
\end{syntax}

\paragraph{Description.} The \lstinline{void} type represents the type whose variables cannot exist! That is, they cannot hold any possible value. Void is used to represent the return type of a function which does not return anything. However, it is also
used to represent the element type of an empty list of set. 

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} The void type is a subtype of everything; that is, it is bottom in the type lattice.

% =======================================================================
% Null
% =======================================================================

\subsection{Null Type}

\begin{syntax}
  \verb+NullType+ & $::=$ & \token{null} \\
\end{syntax}

\paragraph{Description.}  The null type is a special type which should
be used to show the absence of something. It is distinct from void,
since variables can hold the special \lstinline{null}> value (where as
there is no special "\lstinline{void}" value).

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  With all of the problems surrounding
\lstinline{null} and \lstinline{NullPointerException}s in languages
like Java and C, it may seem that this type should be
avoided. However, it remains a very useful abstraction to have around
and, in Whiley, it is treated in a completely safe manner (unlike
e.g. Java).

% =======================================================================
% Bool 
% =======================================================================

\subsection{Bool Type}

\begin{syntax}
 \verb+BoolType+ & $::=$ & \token{bool} \\
\end{syntax}

\paragraph{Description.} Represents the set of boolean values (i.e. \lstinline{true} and \lstinline{false}).

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Bool 
% =======================================================================

\subsection{Byte Type}

\begin{syntax}
 \verb+ByteType+ & $::=$ & \token{byte} \\
\end{syntax}

\paragraph{Description.}  Represents a sequence of 8 bits. 
\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  Unlike for many languages, there is no
representation associated with a byte. For example, to extract an
integer value from a byte, it must be explicitly decoded according to
some representation (e.g. two's compliment) using an auxillary function (e.g. \lstinline{Byte.toInt()}).


% =======================================================================
% Char
% =======================================================================

\subsection{Char Type}

\begin{syntax}
  \verb+CharType+ & $::=$ & \token{char} \\
\end{syntax}

\paragraph{Description.}  Represents a unicode character.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Int
% =======================================================================

\subsection{Int Type}

\begin{syntax}
  \verb+IntType+ & $::=$ & \token{int} \\
\end{syntax}

\paragraph{Description.}  Represents the set of (unbound) integer
values. 

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  Since integer types in Whiley are unbounded, there
is no equivalent to Java's \lstinline{MIN_VALUE} and \lstinline{MAX_VALUE} for \lstinline{int} types.

% =======================================================================
% Real
% =======================================================================

\subsection{Real Type}

\begin{syntax}
  \verb+RealType+ & $::=$ & \token{real} \\
\end{syntax}

\paragraph{Description.}  Represents the set of (unbound) rational
numbers.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Tuples
% =======================================================================

\section{Tuple Types}

\begin{syntax}
  \verb+TupleType+ & $::=$ & \token{(}\ \verb+Type+\ \big(\ \token{,}\
  \verb+Type+\ \big)$^+$\ \token{)}\\
\end{syntax}

\paragraph{Description.}  A tuple type describes a compound type made
up of two or more subcomponents. It is similar to a record, except
that fields are effectively anonymous.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Records
% =======================================================================

\section{Record Types}

\begin{syntax}
  \verb+RecordType+ & $::=$ & \token{\{}\ \verb+Type+\
  \verb+Ident+\ \big(\ \token{,}\ \verb+Type+\ \verb+Ident+\
  \big)$^*$ \big[\ \token{,}\ \token{...}\ \big]\ \token{\}}\\
\end{syntax}

\paragraph{Description.}   A record is made up of a number of fields,
each of which has a unique name. Each field has a corresponding
type. One can think of a record as a special kind of "fixed" map
(i.e. where we know exactly which entries we have).

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  Syntax for functions?  Open versus closed records?

% =======================================================================
% References
% =======================================================================

\section{Reference Types}

\begin{syntax}
  \verb+ReferenceType+ & $::=$ & \token{\&}\ \ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  Represents a reference to an object in Whiley.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Nominal
% =======================================================================

\section{Nominal Types}

\begin{syntax}
  \verb+NominalType+ & $::=$ & \verb+Ident+\\
\end{syntax}

\paragraph{Description.} The existential type represents the an
unknown type, defined at a given position.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Collections
% =======================================================================

\section{Collection Types}

% =======================================================================
% Set
% =======================================================================

\subsection{Set Type}

\begin{syntax}
  \verb+SetType+ & $::=$ & \token{\{} \ \verb+Type+ \ \token{\}} \\
\end{syntax}

\paragraph{Description.}  A set type describes set values whose
elements are subtypes of the element type. For example,
\lstinline|{1,2,3}| is an instance of set type \lstinline|{int}|;
however, \lstinline|{1.345}| is not.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Map
% =======================================================================

\subsection{Map Type}

\begin{syntax}
  \verb+MapType+ & $::=$ & \token{\{} \ \verb+Type+ \ \token{=>} \ \verb+Type+ \ \token{\}} \\
\end{syntax}

\paragraph{Description.}  A map represents a one-many mapping from
variables of one type to variables of another type. For example, the
map type \lstinline|{int=>real}| represents a map from integers to real
values. A valid instance of this type might be \lstinline|{1=>1.2,2=>3.0}|.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% List
% =======================================================================

\subsection{List Type}

\begin{syntax}
  \verb+ListType+ & $::=$ & \token{[} \ \verb+Type+ \ \token{]}\\
\end{syntax}

\paragraph{Description.}  A list type describes list values whose
elements are subtypes of the element type. For example,
\lstinline{[1,2,3]} is an instance of list type \lstinline{[int]}; however, \lstinline{[1.345]} is not.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.} 

% =======================================================================
% Functions
% =======================================================================

\section{Function Types}

\begin{syntax}
  \verb+FunctionType+ & $::=$ & \token{function}\ \token{(}\
  \big[\ \verb+Type+\ \big(\ \token{,}\ \verb+Type+\ \big)$^*$\ \big]\ \token{)}\ \token{=>}\ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Functions
% =======================================================================

\section{Method Types}

\begin{syntax}
  \verb+MethodType+ & $::=$ & \token{method}\ \token{(}\
  \big[\ \verb+Type+\ \big(\ \token{,}\ \verb+Type+\ \big)$^*$\ \big]\ \token{)}\ \token{=>}\ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Unions
% =======================================================================

\section{Union Types}

\begin{syntax}
  \verb+UnionType+ & $::=$ & \verb+IntersectionType+\ \big(\ \token{|}\ \verb+IntersectionType+\
  \big)$^+$\\
\end{syntax}

\paragraph{Description.}   A union type represents a type whose
variables may hold values from any of its "bounds". For example, the
union type \lstinline{null|int} indicates a variable can either hold
an integer value, or \lstinline{null}. 

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}  There must be at least two bounds for a union type to make sense.

% =======================================================================
% Intersections
% =======================================================================

\section{Intersection Types}

\begin{syntax}
  \verb+IntersectionType+ & $::=$ & \verb+TermType+\ \big(\ \token{\&}\ \verb+TermType+\
  \big)$^+$\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

% =======================================================================
% Negations
% =======================================================================

\section{Negation Types}

\begin{syntax}
  NegationType & $::=$ & \token{!}\ \ \verb+Type+\\
\end{syntax}

\paragraph{Description.}  A negation type represents a type which
accepts values {\em not} in a given type.

\paragraph{Examples.}

\paragraph{Semantics.}

\paragraph{Notes.}

\section{Abstract Types}
\subsection{Recursive Types}
\subsection{Effective Tuples}
\subsection{Effective Records}
\subsection{Effective Collections}

\section{Subtyping Algorithms}
Discussion of soundness and completeness.
