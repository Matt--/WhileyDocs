\chapter{Statements}

The execution of a Whiley program is controlled by \gls{statement}s, which cause effects on the environment.  However, statements in Whiley do not produce values.  \Gls{compound_statement} statements may contain other statements.

\section{Blocks}
\label{c_stmts_blocks}

A \gls{statement_block} is a sequence of zero or more consecutive statements which have the same indentation.  Statement blocks are used to group statements together when constructing \gls{compound_statement}s.  For example:
\begin{lstlisting}
function sum([int] items) => int:
    // outer block begins
    int r = 0
    int i = 0
    while i < |items|:
        // inner block begins
        r = r + items[i]
        i = i + 1
        // inner block ends
    //
    return r
    // outer block ends
\end{lstlisting}
The above example contains two statement blocks, one nested inside the other.  The outer block demarcates the body of the \lstinline{sum()} function, whilst the inner block demarcates the body of the \lstinline{while} statement.

% =======================================================================
% AssertStatement
% =======================================================================

\section{Assert Statement}

Represents an {\em assert statement} of the form ``\lstinline{assert e}'', where \lstinline{e} is a \gls{boolean_expression}.  A \gls{fault} will be raised at runtime if the asserted expression evaluates to \lstinline{false}; otherwise, execution will proceed normally.  At verification time, the verifier is forced to ensure that the asserted expression is true for all possible execution paths.  This allows the programmer to specify and check something he/she believes to be true at a given point in the program.

\begin{syntax}
  \verb+AssertStmt+ & $::=$ & \token{assert}\ \verb+Expr+\\
\end{syntax}

\noindent The following illustrates an \lstinline{assert} statement:
\begin{lstlisting}
function abs(int x) => int:
    if x < 0:
        x = -x
    assert x >= 0
    return x
\end{lstlisting}
Here, an assertion is used to check that the value being returned by the \lstinline{abs()} is non-negative.  Since this is a true statement of the function, this statement will never raise a fault.

% =======================================================================
% Assignment Statement
% =======================================================================

\section{Assignment Statement}

As {\em assignment statement} is of the form \lstinline{leftHandSide = rightHandSide}.  Here, the \lstinline{rightHandSide} is any expression, whilst the \lstinline{leftHandSide} must be an \lstinline{LVal} --- that is, an expression permitted on the left-hand side of an assignment.  At runtime, the value generated by evaluating the right-hand side must be a subtype (\S\ref{c_types_subtyping}) of the left-hand side.

\begin{syntax}
  \verb+AssignStmt+ & $::=$ & \verb+LVal+\ \token{=}\ \verb+Expr+\\
\end{syntax}


\noindent The following illustrates different possible assignment statements:
\begin{lstlisting}
x = y       // variable assignment
x.f = y     // field assignment
x[i] = y    // list assignment
x[i].f = y  // compound assignment
\end{lstlisting}
The last assignment here illustrates that the left-hand side of an assignment can be arbitrarily complex, involving nested assignments into lists and records.

% =======================================================================
% Assume Statement
% =======================================================================

\section{Assume Statement}

An {\em assume statement} is of the form ``\lstinline{assume e}'', where \lstinline{e} is a \gls{boolean_expression}.  A \gls{fault} will be raised at runtime if the assumed expression evaluates to \lstinline{false}; otherwise, execution will proceed normally.  At verification time, the verifier will automatically assume that the given expression holds.  Thus, \lstinline{assume} statements provide a way for the programmer to override the verifier.  This is useful where the verifier is unable to establish something that the programmer knows to be true.  Care must be taken to ensure that the assumed expression really does hold.

\begin{syntax}
  \verb+AssumeStmt+ & $::=$ & \token{assume}\ \verb+Expr+\\
\end{syntax}

\noindent The following illustrates an \lstinline{assume} statement:

\begin{lstlisting}
function abs(int x) => (int y)
ensures y >= 0:
    //
    assume x >= 0
    return x
\end{lstlisting}
Here, the programmer has used an assumption to ensure this function passes verification.  This would not appear to be safe in this case, and may lead to a fault at runtime.

% =======================================================================
% Break Statement
% =======================================================================

\section{Break Statement}
\label{c_stmts_break}

% =======================================================================
% Continue Statement
% =======================================================================

\section{Continue Statement}
\label{c_stmts_continue}

% =======================================================================
% Debug Statement
% =======================================================================

\section{Debug Statement}

% =======================================================================
% Do/While Statement
% =======================================================================

\section{Do/While Statement}
\label{c_stmts_do_while}
\begin{syntax}
  \verb+DoWhileStmt+$^\ell$ & $::=$ & \token{do}\ \token{:}
  \verb+Block+$^\gamma$\ \token{while}\ \verb+Expr+\ \big(\
  \token{where}\ \verb+Expr+\ \big)$^*$\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\paragraph{Description.}

\noindent

\paragraph{Notes.} 
% =======================================================================
% For Statement
% =======================================================================

\section{For Statement}
\label{c_stmts_for}
\begin{syntax}
  \verb+ForStmt+$^\ell$ & $::=$ & \token{for}\ \verb+VarPattern+\
  \token{in}\ \verb+Expr+\ \big(\ \token{where}\ \verb+Expr+\
  \big)$^*$\ \token{:} \verb+Block+$^\gamma$\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\paragraph{Description.}

\noindent

\paragraph{Notes.} 

% =======================================================================
% If Statement
% =======================================================================

\section{If Statement}
\label{c_stmts_if}
An \lstinline{if} statement conditionally executes a \gls{statement_block} based on the outcome of one or more expressions.  Chaining of \lstinline{if} statements is permitted, and an optional \lstinline{else} branch may be given.  The expression(s) are referred to as {\em conditions} and must be \gls{boolean_expression}s.  The first block is referred to as the {\em true branch}, whilst the optional \lstinline{else} block is referred to as the {\em false branch}.

\begin{syntax}
  \verb+IfStmt+$^\ell$ & $::=$ & \token{if}\ \verb+Expr+\ \token{:}
  \verb+Block+$^\gamma$\ \big( \token{else} \token{if}\ \verb+Expr+\ \token{:}
  \verb+Block+$^{\omega_i}$\ \big)$^*$ \\
&& \big[ \token{else} \token{:} \verb+Block+$^\phi$\ \big]\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$ and $\forall i.\ell <
  \omega_i$ and $\ell < \phi$)}\\
\end{syntax}

\noindent The following illustrates an \lstinline{if} statement:

\begin{lstlisting}
function max(int x, int y) => int:
    if(x > y):
        return x
    else if(x == y):
        return 0
    else:
        return y
\end{lstlisting}
Here, we see an \lstinline{if} statement with two conditional outcomes
and one default outcome.

% =======================================================================
% While Statement
% =======================================================================

\section{While Statement}
\label{c_stmts_while}
A while statement repeatedly executes a statement block until an expression (the condition) evaluates to \lstinline{false}.  Optional \lstinline{where} clause(s) are permitted which, together, are commonly referred to as the \gls{loop_invariant}.  

\begin{syntax}
  \verb+WhileStmt+$^\ell$ & $::=$ & \token{while}\ \verb+Expr+\ \big(\
  \token{where}\ \verb+Expr+\ \big)$^*$\ \token{:}\ \verb+Block+$^\gamma$\ \\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\noindent The following illustrates an \lstinline{while} statement:

\begin{lstlisting}
function sum([int] xs) => int:
  int r = 0
  int i = 0
  while i < |xs| where i >= 0:
    r = r + xs[i]
    i = i + 1
  return r
\end{lstlisting}
Here, we see a simple \lstinline{while} statement which sums the elements of variable \lstinline{xs}, storing the result in variable \lstinline{r}.  A loop invariant is given which establishes that variable \lstinline{i} is non-negative.

\paragraph{Notes.}   When multiple \lstinline{where} clauses are given, these are combined using a conjunction to form the loop invariant.  The combined invariant must hold on entry to the loop and after each iteration.  Thus, when the condition evaluates to \lstinline{false}, the loop invariant is guaranteed to hold.  However, the loop invariant need not hold when the loop is exited using a \lstinline{break} (\S\ref{c_stmts_break}) statement.

% =======================================================================
% ReturnStatement
% =======================================================================

\section{Return Statement}
\label{c_stmts_return}
A {\em return statement} has an optional expression referred to as the {\em return value}.  At runtime, this statement returns control to the caller of the enclosing function or method.  At verification time, the verifier will ensure the returned value meets the \gls{postcondition} of the enclosing function or method.

\begin{syntax}
  \verb+ReturnStmt+ & $::=$ & \token{return}\ \big[\ \verb+Expr+\
  \big]\\
\end{syntax}

\noindent The following illustrates a \lstinline{return} statement:

\begin{lstlisting}
function f(int x) => int:
    return x + 1
\end{lstlisting}
Here, we see a simple simple function which returns the increment of its parameter \lstinline{x} using a \lstinline{return} statement.


\paragraph{Notes.} The returned expression (if there is one) must begin on the same line as the statement itself.

% =======================================================================
% Skip Statement
% =======================================================================

\section{Skip Statement}

% =======================================================================
% Switch Statement
% =======================================================================

\section{Switch Statement}
\label{c_stmts_switch}
\begin{syntax}
  \verb+SwitchStmt+ & $::=$ &\\
\end{syntax}

\paragraph{Description.}

\noindent

\paragraph{Notes.} 

% =======================================================================
% ThrowStatement
% =======================================================================

\section{Throw Statement}
\label{c_stmts_throw}
A {\em throw statement} causes an exception to thrown which, if not caught locally, causes an \gls{abrupt_termination} of the current function or method.  Functions or methods which may terminate abruptly must declare appropriate an throws clause (\S\ref{c_source_files_function_decl},\S\ref{c_source_files_method_decl}) which contains al potentially thrown exceptions.

\begin{syntax}
  \verb+ThrowStmt+ & $::=$ & \token{throw}\ \verb+Expr+\\
\end{syntax}

\noindent The following illustrates a \lstinline{throw} statement:

\begin{lstlisting}
function parseInt(int pos, string input) => (int,int)
// Throws a syntax error if the string is malformed
throws SyntaxError:
    //
    int start = pos
    // check for negative input
    if pos < |input| && input[pos] == '-':
        pos = pos + 1
    // match remainder
    while pos < |input| && Char.isDigit(input[pos]):
        pos = pos + 1
    // check for error
    if pos == start:
        throw SyntaxError("Missing number",start,pos)
    // done
    return Int.parse(input[start..pos]),pos
\end{lstlisting}
Here, we see a simple function which parses a string into an integer.  The function declares that a \lstinline{SyntaxError} may be thrown.  This is required for two reasons:  firstly, the input contains no digits then an \lstinline{SyntaxError} is thrown by this function.  Additionally, the function \lstinline{Int.parse()} is declared to throw a \lstinline{SyntaxError} and, since it is not caught, this declaration must be propagated.

% =======================================================================
% Try/Catch Block
% =======================================================================

\section{Try/Catch Statement}
\label{c_stmts_try_catch}
\begin{syntax}
  \verb+TryCatchStmt+ & $::=$ &\\
\end{syntax}

\paragraph{Description.}

\noindent

\paragraph{Notes.} 

% =======================================================================
% Variable Declarations
% =======================================================================

\section{Variable Declaration Statement}
\label{c_stmts_var_decl}
A \gls{variable_declaration} statement has an optional expression assignment referred to as a \gls{variable_initialiser}.  If an initialiser is given, this will be evaluated and assigned to the variable when the declaration is executed.  

\begin{syntax}
  \verb+VarDecl+ & $::=$ & \verb+Type+\ \verb+Ident+\ \big[\
  \token{=}\ \verb+Expr+\ \big]\\
\end{syntax}

\noindent Some example variable declarations are:
\begin{lstlisting}
int x
int y = 1
int z = x + y
\end{lstlisting}
Here we see three variable declarations.  The first has no initialiser, whilst the second and third have initialisers.
