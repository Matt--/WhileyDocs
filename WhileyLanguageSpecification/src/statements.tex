\chapter{Statements}

The execution of a Whiley program is controlled by \gls{statement}s, which cause effects on the environment.  However, statements in Whiley do not produce values.  \Gls{compound_statement} statements may contain other statements.

\section{Blocks}
\label{c_stmts_blocks}

A \gls{statement_block} is a sequence of zero or more consecutive statements which have the same indentation.  Statement blocks are used to group statements together when constructing \gls{compound_statement}s.  For example:
\begin{lstlisting}
function sum([int] items) => int:
    // outer block begins
    int r = 0
    int i = 0
    while i < |items|:
        // inner block begins
        r = r + items[i]
        i = i + 1
        // inner block ends
    //
    return r
    // outer block ends
\end{lstlisting}

The above example contains two statement blocks, one nested inside the other.  The outer block demarcates the body of the \lstinline{sum()} function, whilst the inner block demarcates the body of the \lstinline{while} statement.

% =======================================================================
% AssertStatement
% =======================================================================

\section{Assert Statement}

Represents an {\em assert statement} of the form ``\lstinline{assert e}'', where \lstinline{e} is a \gls{boolean_expression}.  A \gls{fault} will be raised at runtime if the asserted expression evaluates to \lstinline{false}; otherwise, execution will proceed normally.  At verification time, the verifier is forced to ensure that the asserted expression is true for all possible execution paths.  This allows the programmer to specify and check something he/she believes to be true at a given point in the program.

\begin{syntax}
  \verb+AssertStmt+ & $::=$ & \token{assert}\ \verb+Expr+\\
\end{syntax}

\paragraph{Examples.} The following illustrates an \lstinline{assert} statement:
\begin{lstlisting}
function abs(int x) => int:
    if x < 0:
        x = -x
    assert x >= 0
    return x
\end{lstlisting}

Here, an assertion is used to check that the value being returned by the \lstinline{abs()} is non-negative.  Since this is a true statement of the function, this statement will never raise a fault.

% =======================================================================
% Assignment Statement
% =======================================================================

\section{Assignment Statement}

Represents an {\em assignment statement} of the form \lstinline{leftHandSide = rightHandSide}.  Here, the \lstinline{rightHandSide} is any expression, whilst the \lstinline{leftHandSide} must be an \lstinline{LVal} --- that is, an expression permitted on the left-hand side of an assignment.  At runtime, the value generated by evaluating the right-hand side must be a subtype (\S\ref{c_types_subtyping}) of the left-hand side.

\begin{syntax}
  \verb+AssignStmt+ & $::=$ & \verb+LVal+\ \token{=}\ \verb+Expr+\\
\end{syntax}


\paragraph{Examples.} The following illustrates different possible assignment statements:
\begin{lstlisting}
x = y       // variable assignment
x.f = y     // field assignment
x[i] = y    // list assignment
x[i].f = y  // compound assignment
\end{lstlisting}

The last assignment here illustrates that the left-hand side of an assignment can be arbitrarily complex, involving nested assignments into lists and records.

% =======================================================================
% Assume Statement
% =======================================================================

\section{Assume Statement}

Represents an {\em assume statement} of the form ``\lstinline{assume e}'', where \lstinline{e} is a \gls{boolean_expression}.  A \gls{fault} will be raised at runtime if the assumed expression evaluates to \lstinline{false}; otherwise, execution will proceed normally.  At verification time, the verifier will automatically assume that the given expression holds.  Thus, \lstinline{assume} statements provide a way for the programmer to override the verifier.  This is particularly useful in cases where the verifier is unable to establish something that the programmer knows to be true.  However, care must be taken to ensure that the assumed expression really does hold.

\begin{syntax}
  \verb+AssumeStmt+ & $::=$ & \token{assume}\ \verb+Expr+\\
\end{syntax}

The following illustrates a simple function which uses an \lstinline{assume} statement to meet its postcondition:

\begin{lstlisting}
function abs(int x) => (int y)
ensures y >= 0:
    //
    assume x >= 0
    return x
\end{lstlisting}

Here, the programmer has used an assumption to ensure this function passes verification.  This would not appear to be safe in this case, and may lead to a fault at runtime.

% =======================================================================
% ReturnStatement
% =======================================================================

\section{Return Statement}

Represents a {\em return statement} with an optional expression is referred to as the {\em return value}.

\begin{syntax}
  \verb+ReturnStmt+ & $::=$ & \token{return}\ \big[\ \verb+Expr+\
  \big]\\
\end{syntax}

\paragraph{Examples.} The following illustrates a simple function
which returns the increment of its parameter \lstinline{x}:

\begin{lstlisting}
function f(int x) => int:
    return x + 1
\end{lstlisting}

Here, we see a simple \lstinline{return} statement which returns an \lstinline{int} value.

\paragraph{Notes.}  The returned expression (if there is one) must
begin on the same line as the return statement itself.

% =======================================================================
% ThrowStatement
% =======================================================================

\section{Throw Statement}

\begin{syntax}
  \verb+ThrowStmt+ & $::=$ & \token{throw}\ \verb+Expr+\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% Variable Declarations
% =======================================================================

\section{Variable Declarations}

Represents a \gls{variable_declaration} which has an optional expression assignment referred to as an \gls{variable_initialiser}.  If an initialiser is given, then this will be evaluated and assigned to the variable when the declaration is executed.

\begin{syntax}
  \verb+VarDecl+ & $::=$ & \verb+Type+\ \verb+Ident+\ \big[\
  \token{=}\ \verb+Expr+\ \big]\\
\end{syntax}

\paragraph{Examples.} Some example variable declarations are:
\begin{lstlisting}
int x
int y = 1
int z = x + y
\end{lstlisting}

\paragraph{Notes.} 


% =======================================================================
% If Statement
% =======================================================================

\section{If Statement}

Represents a classical \lstinline{if} statement which supports
chaining and an optional \lstinline{else} branch.  The expression(s)
are referred to as {\em conditions} and must be
\gls{boolean_expression}s.  The first block is referred to as the {\em
  true branch}, whilst the optional \lstinline{else} block is referred to as the {\em false branch}.

\begin{syntax}
  \verb+IfStmt+$^\ell$ & $::=$ & \token{if}\ \verb+Expr+\ \token{:}
  \verb+Block+$^\gamma$\ \big( \token{else} \token{if}\ \verb+Expr+\ \token{:}
  \verb+Block+$^{\omega_i}$\ \big)$^*$ \\
&& \big[ \token{else} \token{:} \verb+Block+$^\phi$\ \big]\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$ and $\forall i.\ell <
  \omega_i$ and $\ell < \phi$)}\\
\end{syntax}

\paragraph{Examples.} The following illustrates:

\begin{lstlisting}
function max(int x, int y) => int:
    if(x > y):
        return x
    else if(x == y):
        return 0
    else:
        return y
\end{lstlisting}

\paragraph{Notes.} 

% =======================================================================
% While Statement
% =======================================================================

\section{While Statement}

Represents a while statement with optional \lstinline{where} clause(s) commonly referred to as \gls{loop_invariant}s.

\begin{syntax}
  \verb+WhileStmt+$^\ell$ & $::=$ & \token{while}\ \verb+Expr+\ \big(\
  \token{where}\ \verb+Expr+\ \big)$^*$\ \token{:}\ \verb+Block+$^\gamma$\ \\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\paragraph{Examples.} As an example:

\begin{lstlisting}
function sum([int] xs) => int:
  int r = 0
  int i = 0
  while i < |xs| where i >= 0:
    r = r + xs[i]
    i = i + 1
  return r
\end{lstlisting}

\paragraph{Notes.}   When multiple \lstinline{where} clauses are
given, these are combined using a conjunction. The combined invariant
defines a condition which must be true on every iteration of the loop.

% =======================================================================
% Do/While Statement
% =======================================================================

\section{Do/While Statement}

\begin{syntax}
  \verb+DoWhileStmt+$^\ell$ & $::=$ & \token{do}\ \token{:}
  \verb+Block+$^\gamma$\ \token{while}\ \verb+Expr+\ \big(\
  \token{where}\ \verb+Expr+\ \big)$^*$\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% For Statement
% =======================================================================

\section{For Statement}

\begin{syntax}
  \verb+ForStmt+$^\ell$ & $::=$ & \token{for}\ \verb+VarPattern+\
  \token{in}\ \verb+Expr+\ \big(\ \token{where}\ \verb+Expr+\
  \big)$^*$\ \token{:} \verb+Block+$^\gamma$\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% Switch Statement
% =======================================================================

\section{Switch Statement}

\begin{syntax}
  \verb+SwitchStmt+ & $::=$ &\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% Try/Catch Block
% =======================================================================

\section{Try/Catch Statement}

\begin{syntax}
  \verb+TryCatchStmt+ & $::=$ &\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 
