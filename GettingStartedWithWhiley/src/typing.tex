\newpage
\section{Flexible Types}
The previous section introduced us to the basic types found in Whiley,
such as integers (\lstinline{int}), rationals (\lstinline{real}) and
booleans (\lstinline{bool}).  However, unlike many languages, Whiley
provides a flexible and powerful approach to typing which go well
beyond the basic forms.  In this section, we will examine this in more
detail.

\subsection{Flow Typing}
To improve the programmer experience and reduce unnecessary tedium,
Whiley employs a {\em flow typing} system.  What this means is that
the type of a variable can vary at different points within a function.
To make this work, Whiley employs {\em union types}~\cite{BC91,IN07} along with {\em variable retyping}.  The
following example illustrates how this works (where the body of
\lstinline{indexOf()} is left out for brevity):

\begin{lstlisting}
 function indexOf(string str, char c) => null|int:
    ...

 function split(string str, char c) => [string]:
    var idx = indexOf(str,c)
    // idx has type null$|$int
    if idx is int:
        // idx now has type int
        int below = str[0..idx]
        int above = str[idx..]
        return [below,above]
    else:
        // idx now has type null
        return [str] // no occurrence
\end{lstlisting}
Here, \lstinline{indexOf()} returns the first index of a character in
the string, or \lstinline{null} if there is none.  The type
\lstinline{null|int} is a {\em union type}, meaning it is either an
\lstinline{int} or \lstinline{null}.  The \lstinline{split()} function
splits a string into two pieces based on the first occurrence of a
given character \lstinline{c}, or leaves the string as is otherwise.
It calls \lstinline{indexOf()} to determine the first occurrence of
\lstinline{c} in \lstinline{str}.  Observe that variable
\lstinline{idx} has been declared as type \lstinline{var}, meaning the
compiler will automatically infer the best possible type for it.

In the above example, Whiley's flow typing system seamlessly ensures
that \lstinline{null} is never dereferenced.  This is because the type
\lstinline{null|int} cannot be treated as an \lstinline{int}.
Instead, one must first check it is an \lstinline{int} using a type
test, such as ``\lstinline{idx is int}''.  Whiley automatically
{\em retypes} \lstinline{idx} to \lstinline{int} when this is known to be
true, thereby avoiding any awkward and unnecessary syntax (e.g. a cast
as required in many languages).

\begin{insight}{Null References.}  In many languages (e.g. C/C++,
  Java, etc) the use of \lstinline{null} is a significant source of
  error (see e.g.~\cite{Hoa09}).  For example, in Java dereferencing
  the \lstinline{null} value gives rise to a
  \lstinline{NullPointerException}, which is regarded as the most
  common form of error in Java~\cite{XYZ}.  The issue is that, in such
  languages, one can treat {\em nullable} references as though they
  are {\em non-null} references~\cite{Pier02}.  In the research
  literature, there have been many proposals to solve this problem
  using static type systems
  (e.g.~\cite{PQVHV01,FL03,KH07,CFJJ06,CJ07,MPPD08,Hub08,HJP08}).
  Unfortunately, at the time of writing, very few languages have
  incorporated such ideas.
\end{insight}

\begin{insight}{Intersections and Negations.}
  Whiley also supports so-called {\em intersection} and {\em negation}
  types.  Whilst these can be expressed directly in source code, they
  are generally less useful than unions.
\end{insight}

\begin{insight}{Untagged Unions}.  Often confusion surrounding untagged
    versus tagged unions.  The latter are more common, and sometimes
    known as {\em sum types}.
\end{insight}

\subsection{Recursive Types}
To represent tree-like structures, Whiley provides {\em recursive
  types} which are similar to the abstract data types found in
functional languages (e.g. Haskell, ML, etc).  For example:
\begin{lstlisting}
// A linked list is either the empty list or a link
type LinkedList is EmptyList | Link

// The empty list contains no links
type EmptyList is null

// A single link in a linked list
type Link is {int data, LinkedList next}

// Return the length of a linked list (i.e. the number of links it contains)
int length(LinkedList l):
  if l is null:    
    return 0 // l now has type null
  else:    
    return 1 + length(l.next) // l now has type \{int data, LinkedList next\}
\end{lstlisting}
Here, \lstinline{LinkedList} is a recursive type representing a linked
list (i.e. a sequence of zero or more links).  The empty list is
defined as \lstinline{null}, whilst each link contains a
\lstinline{data} field.  The type \lstinline{LinkedList} is defined in
terms of itself (i.e. it is recursive) and describes linked lists of
arbitrary size.

\begin{insight}{Value Semantics.}
  As discussed in \S\ref{value_semantics} all compounds structures in
  Whiley are passed by value, {\em including recursive types}.  This
  differs from common languages (e.g. Java), where linked structures
  are typically composed from {\em references} to link objects.  This
  means, for example, that linked structures in such languages can
  share substructures, leading to subtle and hard-to-find bugs.  In
  Whiley linked structures, such as \lstinline{LinkedList}, can never
  share substructure.
\end{insight}

The above example also serves as another illustration of flow typing
in Whiley.  More specifically, on the false branch of the type test
``\lstinline{l is null}'', variable \lstinline{l} is automatically
retyped to \lstinline+{int data, LinkedList next}+ --- thus ensuring
the subsequent dereference of \lstinline{l.next} is safe.  No casts
are required as would be needed for a conventional imperative language
(e.g. Java).  Finally, like all compound structures, the semantics of
Whiley dictates that recursive data types are passed by value (or, at
least, appear to be from the programmer's perspective).

%\subsection{Polymorphism \& Encapsulation}
%Two important hallmarks of the object-oriented paradigm are
%polymorphism and encapsulation.  The former is typically achieved
%through inheritance and/or interfaces, whilst the latter typically
%exploits \lstinline{public} / \lstinline{private} modifiers.  Whiley
%does not permit \lstinline{public} or \lstinline{private} modifiers in
%records.  Instead, Whiley employs a simple form of {\em existential
%type}~\cite{}, illustrated as follows:
%
%\begin{lstlisting}
% define Shape as { 
%   bool contains(int x, int y, Shape this), 
%   ... 
% }
%\end{lstlisting}
%This declares what is, essentially, an interface.  The
%``\lstinline{...}''  notation is significant here, as it denotes
%unknown --- or {\em existential} --- state~\cite{Cook09}.  We can then
%``implement'' this interface as follows:
%
%\begin{lstlisting}
% define Square as {
%   int x, int y, int width, int height,   
%   bool contains(int x, int y, Square this)
% }
%
% bool defSqContains(int x, int y, Square sq):
%     if x >= sq.x && x < (sq.x + sq.width):
%         return y >= sq.y && 
%                y < (sq.y + sq.height)
%     return false
%
% Square defSquare(int x, int y, int w, int h):
%     return {x: x, y: y, width: w, height: h,
%             contains: &defSqContains}
%\end{lstlisting}
%{\bf THIS NEEDS WORK --- IT'S BROKEN}

\subsection{Structural vs Nominal Types}
Statically typed languages, such as Java, employ {\em nominal typing}
for recursive data types.  This means that two otherwise identical
types with different names are considered distinct and, for example, a
variable of one type cannot flow into the other.  In contrast, Whiley employs {\em structural typing} of records~\cite{Card88} to give greater flexibility.  This means that the name of a type is, generally speaking, unimportant.  Instead, identical types (i.e. those with identical {\em structure}) with different names are still considered identical in Whiley.  For example:

\begin{lstlisting}
// Define the notion of a "rectangle"
type Rectangle is { int x, int y, int width, int height }
// Define the notion of a "bounding box"
type BoundingBox is { int x, int y, int width, int height }

// Define a function for computing the area of a rectangle
function area(Rectangle rect) => int:
    return rect.width * rect.height
\end{lstlisting}

In this example, the types \lstinline{Rectangle} and \lstinline{BoundingBox} are {\em identical} and can be used interchangeably.  For example, if we have a variable of type \lstinline{BoundingBox}, we can safely pass it to the \lstinline{area()} function above to compute its area.

\subsubsection{Nominal Types}

It is possible to simulate nominal types in Whiley.

\subsection{Subtyping}

An important concept in many modern programming languages is that of {\em subtyping}.  This defines a relationship between otherwise different types (i.e. which do not have identical structure).  To understand this, consider the following type declarations:
\begin{lstlisting}
type Link is {int data, LinkedList next}
type LinkedList is null | Link
type OrderedList is null | {
  int data, int order, OrderedList next
}
\end{lstlisting}
Here, we have defined a standard linked list and a specialised
``ordered'' list.  The intuition is that \lstinline{order < next.order} for each node in an \lstinline{OrderedList} (although the details of how this is done are unimportant here).   These two types are not considered identical because they have different structure (i.e. \lstinline{OrderedList} has an additional field, \lstinline{order}).  However, there is still a {\em subtyping relationship} between them.  More specifically, \lstinline{OrderedList} is considered a {\em subtype} of \lstinline{LinkedList}.  This means that an instance of \lstinline{OrderedList} can be used where a \lstinline{LinkedList} was expected.  For example:

\begin{lstlisting}
function sum(LinkedList l) => int:
    if l is null:
        return 0
    else:
        return l.data + sum(l.next)
\end{lstlisting}

This defines a simple recursive function for computing the length of a \lstinline{LinkedList}.  Furthermore, instances of \lstinline{OrderedList} can be passed into this function to compute their length as well.

\begin{insight}{Implicit Coercions.}
This is an example of an implicit coercion.  I think perhaps we should require a cast to avoid the implicitness and make explicit that things are being thrown away.
\end{insight}