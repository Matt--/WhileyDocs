\newpage
\section{More Types}
The previous section introduced us to the basic types found in Whiley,
such as integers (\lstinline{int}), rationals (\lstinline{real}) and
booleans (\lstinline{bool}).  However, unlike many languages, Whiley
provides a flexible and powerful approach to typing which go well
beyond the basic forms.  In this section, we will examine this in more
detail.

\subsection{Flow Typing}
To improve the programmer experience and reduce unnecessary tedium,
Whiley employs a {\em flow typing} system.  What this means is that
the type of a variable can vary at different points within a function.
To make this work, Whiley employs {\em union types}
(e.g.~\cite{BC91,IN07}) along with {\em variable retyping}.  The
following example illustrates how this works, where the body of
\lstinline{indexOf()} is left out for brevity:

\begin{lstlisting}
 function indexOf(string str, char c) => null|int:
    ...

 function split(string str, char c) => [string]:
    var idx = indexOf(str,c)
    // idx has type null$|$int
    if idx is int:
        // idx now has type int
        int below = str[0..idx]
        int above = str[idx..]
        return [below,above]
    else:
        // idx now has type null
        return [str] // no occurrence
\end{lstlisting}
Here, \lstinline{indexOf()} returns the first index of a character in
the string, or \lstinline{null} if there is none.  The type
\lstinline{null|int} is a union type, meaning it is either an
\lstinline{int} or \lstinline{null}.

In the above example, Whiley's flow-sensitive type system seamlessly
ensures that \lstinline{null} is never dereferenced.  This is because
the type \lstinline{null|int} cannot be treated as an \lstinline{int}.
Instead, one must first check it {\em is} an \lstinline{int} using a
type test, such as ``\lstinline{idx is int}''.  Whiley automatically
retypes \lstinline{idx} to \lstinline{int} when this is known to be
true, thereby avoiding any awkward and unnecessary syntax (e.g. a cast
as required in e.g.~\cite{ANMM06,MPPD08}).

\begin{insight}{Null References.}  In many languages (e.g. C/C++,
  Java, etc) the use of \lstinline{null} is a significant source of
  error (see e.g.~\cite{Hoa09}).  For example, in Java dereferencing
  the \lstinline{null} value gives rise to a
  \lstinline{NullPointerException}, which is regarded as the most
  common form of error in Java~\cite{XYZ}.  The issue is that, in such
  languages, one can treat {\em nullable} references as though they
  are {\em non-null} references~\cite{Pier02}.  In the research
  literature, there have been many proposals to solve this problem
  using static type systems
  (e.g.~\cite{PQVHV01,FL03,KH07,CFJJ06,CJ07,MPPD08,Hub08,HJP08}).
  Unfortunately, at the time of writing, very few languages have
  incorporated such ideas.
\end{insight}

\begin{insight}{Intersections and Negations.}
  Whiley also supports so-called {\em intersection} and {\em negation}
  types.  Whilst these can be expressed directly in source code, they
  are generally less useful than unions.
\end{insight}

\subsection{Recursive Types}

%\subsection{Polymorphism \& Encapsulation}
%Two important hallmarks of the object-oriented paradigm are
%polymorphism and encapsulation.  The former is typically achieved
%through inheritance and/or interfaces, whilst the latter typically
%exploits \lstinline{public} / \lstinline{private} modifiers.  Whiley
%does not permit \lstinline{public} or \lstinline{private} modifiers in
%records.  Instead, Whiley employs a simple form of {\em existential
%type}~\cite{}, illustrated as follows:
%
%\begin{lstlisting}
% define Shape as { 
%   bool contains(int x, int y, Shape this), 
%   ... 
% }
%\end{lstlisting}
%This declares what is, essentially, an interface.  The
%``\lstinline{...}''  notation is significant here, as it denotes
%unknown --- or {\em existential} --- state~\cite{Cook09}.  We can then
%``implement'' this interface as follows:
%
%\begin{lstlisting}
% define Square as {
%   int x, int y, int width, int height,   
%   bool contains(int x, int y, Square this)
% }
%
% bool defSqContains(int x, int y, Square sq):
%     if x >= sq.x && x < (sq.x + sq.width):
%         return y >= sq.y && 
%                y < (sq.y + sq.height)
%     return false
%
% Square defSquare(int x, int y, int w, int h):
%     return {x: x, y: y, width: w, height: h,
%             contains: &defSqContains}
%\end{lstlisting}
%{\bf THIS NEEDS WORK --- IT'S BROKEN}

\subsection{Structural Types}
Statically typed languages, such as Java, employ nominal typing for
recursive data types.  This results in rigid hierarchies which are
often difficult to extend~\cite{MA08}.  In contrast, Whiley employs
{\em structural subtyping} of records~\cite{Card88} to give greater
flexibility.

Suppose we wish to extend our expressions from Figure~\ref{eg1} with
assignment statements.  A common issue arises as the left-hand side of
an assignment is a restricted form of expression, often called an {\em
  lval}.  In a language like Java, we can capture this nicely using
interfaces:
\begin{lstlisting}
 interface Expr { ... }
 interface LVal { ... }
 class ListAccess implements Expr,LVal { ...}
 class Var implements Expr,LVal { ... }
 class Int implements Expr { ... }
\end{lstlisting}
However, suppose the code for expressions was part of an existing
library, and we are trying to add statements after the fact.  In a
language like Java, this presents a problem as we cannot
retroactively insert the necessary \lstinline{LVal} interface to
\lstinline{Var} and \lstinline{ListAccess}.

In Whiley, adding the notion of an \lstinline{LVal} is easy to do
retroactively because of structural subtyping:

\begin{lstlisting}
 define LVal as Var | ListAccess 
 define Assign as {LVal lhs, Expr rhs}
 
 Expr parseExpression():
     ...

 null|Assign parseAssign():
     le = parseExpression()
     match(":=")
     re = parseExpression()
     if le is LVal:
         return {lhs: le, rhs: re}
     else:
         return null // syntax error
\end{lstlisting}
Here, \lstinline{LVal} is implicitly a subtype of \lstinline{Expr} ---
i.e. there is no need for an explicit declaration of this, as would be
required in Java.  That is, they can be defined entirely separately
from each other (e.g. in different files, packages or entirely
separate programs) --- and yet, \lstinline{LVal} remains a subtype of
\lstinline{Expr}.

\subsection{Structural Subtyping.}
Whiley permits subtyping between recursive structural types.
\begin{lstlisting}
 define Link as {int data, LinkedList next}
 define LinkedList as null | Link
 define OrderedList as null | {
   int data, int order, OrderedList next
 }

 int sum(LinkedList l):
     if l is null:
         return 0
     else:
         return l.data + sum(l.next)
\end{lstlisting}
Here, we have defined a standard linked list and a specialised
``ordered'' list where \lstinline{order < next.order} for each node
(see e.g.~\cite{DS87}).  Whiley type checks this function by showing
that \lstinline{OrderedList} is a structural subtype of
\lstinline{LinkedList} --- despite this relationship not being
identified explicitly in the program.  Type checking in the presence
of recursive structural types is a well-known and challenging
problem~\cite{GLP02,CA93,KPS93} which is further compounded in Whiley
by the presence of flow-sensitive reasoning.

