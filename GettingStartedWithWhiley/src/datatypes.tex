\newpage
\section{Quick Walkthrough}
This section provides a quick walk through of the main concepts and
ideas in the Whiley language.  Through a series of short examples,
we'll introduce the basic building blocks of the language.

\subsection{Booleans and Numbers}

As found in many languages, Whiley supports a range of primitive
datatypes for representing boolean, integers, real numbers, bytes,
characters, etc.  Of these, the most commonly used are:

\begin{itemize}
\item {\bf Booleans} are denoted by the type \lstinline{bool}.  This is the
  simplest of the primitive datatypes, and has only two possible
  values: \lstinline{true} or \lstinline{false}.
\item {\bf Integers} are denoted by the type \lstinline{int}.  Integers in
  Whiley are {\em unbounded}. This means that, in theory at least, a
  variable of type int can take on {\em any possible integer value};
  this differs from many other languages (e.g. Java), which limit the
  number of possible values (e.g. following 32-bit twoâ€™s complement).
\item {\bf Real Numbers} are denoted by the type
  \lstinline{real}. Reals in Whiley are {\em unbounded
    rationals}. This means that, in theory at least, a variable of
  type real can take on {\em any possible rational value}. Again, this
  offers significantly better precision than, for example,
  \lstinline{float} or \lstinline{double} types based on IEEE754 as
  found in other languages (e.g. Java).
\end{itemize}



\paragraph{Subtyping.} Whiley also provides strong guarantees
regarding subtyping of primitive types.  In Whiley, \lstinline{int}s
and \lstinline{real}s represent unbounded integers and rationals,
which ensures \lstinline{int}$\;\le\;$\lstinline{real} has true subset
semantics (i.e. every \lstinline{int} can be represented by a
\lstinline{real}).  This is not true for e.g. Java, where there are
\lstinline{int} (resp. \lstinline{long}) values which cannot be
represented using \lstinline{float}
(resp. \lstinline{double})~\cite[\S5.1.2]{GJSB05}.

\subsection{Sets, Lists and Maps}

\subsection{Records and Tuples}

\subsection{Strings and Characters}

\subsection{Value Semantics}
\label{value_semantics}
In Whiley, all compound structures (e.g. lists, sets, and records)
have {\em value semantics}.  This means they are passed and returned
by-value (as in Pascal, MATLAB or most functional languages).  But, unlike
functional languages (and like Pascal), values of compound types can
be updated in place.

Value semantics implies that updates to a variable only affects that
variable, and that information can only flow out of a function through
its return value.  Whiley has no general, mutable heap comparable to
those found in object-oriented languages.  Consider:
\begin{lstlisting}
 int f([int] xs):
     ys = xs
     xs[0] = 1
     ...
\end{lstlisting}
The semantics of Whiley dictate that, having assigned \lstinline{xs}
to \lstinline{ys} as above, the subsequent update to \lstinline{xs}
does not affect \lstinline{ys}.  Arguments are also passed by value,
hence \lstinline{xs} is updated inside \lstinline{f()} and this does
not affect \lstinline{f}'s caller.  That is, \lstinline{xs} is not a
{\em reference} to a list of \lstinline{int}; rather, it {\em is} a
list of \lstinline{int}s and assignments to it do not affect state
visible outside of \lstinline{f()}. 

Whilst this approach may seem inefficient, a variety of techniques
exist (e.g. reference counting) to ensure efficiency (see
e.g.~\cite{LH11,Shank01,Ode91}).  Indeed, the underlying
implementation does pass compound structures by reference and copies
them only when absolutely necessary.

